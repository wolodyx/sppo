
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Файловая система &#8212; Системное и прикладное ПО</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Процессы" href="process-management.html" />
    <link rel="prev" title="Инструментальные средства" href="development-tools.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Системное и прикладное ПО</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Введение в учебный предмет
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Введение
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="computer-in-life.html">
   Компьютер в жизни человека
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="binary-code.html">
   Двоичный код
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computer-hardware.html">
   Типы компьютеров
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computer-software.html">
   Программное обеспечение
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Операционная система
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="operating-system.html">
   Операционная система
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="development-tools.html">
   Инструментальные средства
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Файловая система
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="process-management.html">
   Процессы
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Связь с программами
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ipc.html">
   Межпроцессное взаимодействие
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="text-based-user-interface.html">
   Текстовый интерфейс
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="command-line-format.html">
     Формат команд командной строки
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="graphical-user-interface.html">
   Графический интерфейс
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Разработка программ
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="software-license.html">
   Лицензирование
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="programming-languages.html">
   Языки программирования
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-development.html">
   Проект программы
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-configuration.html">
   Конфигурирование
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-distribution.html">
   Распространение
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-installation.html">
   Установка
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Практические занятия
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/create-virtual-machine.html">
   Создание виртуальной машины
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/view-edit-text.html">
   Просмотр и редактирование текста
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/file-system.html">
   Работа с файловой системой
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/help-system.html">
   Справочная система man
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/environment-variables.html">
   Работа с переменными среды
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/command-line-parse.html">
   Разбор аргументов программы
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lesson/file-system.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   Введение
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   Накопители информации
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   Организация файлов
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   Каталоги и пути
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   Метаданные файла
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   Файлы-ссылки
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#unix">
   Стандартные каталоги в UNIX
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   Файловая система
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   Журналирование
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   Дефрагментация диска
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fat">
   Файловая система FAT
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id11">
     Файловые операции в FAT
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   Заключение
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   Использованные источники
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id14">
   Вопросы для самоконтроля
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="id1">
<h1>Файловая система<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>Введение<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>В состав компьютера входят два типа памяти: оперативная и постоянная.
Оперативная память тесно связана с процессором и используется им для хранения исполняемых команд и обрабатываемых данных.
Команды и данные загружаются из нее в процессор, исполняются, а результат возвращается обратно в нее же.
Получившийся после выполнения программы результат отправляется в постоянную память, чтобы освободить оперативную для следующих программ.
Получается круговорот данных внутри компьютера: программы и данные загружаются в оперативную память из постоянной памяти, а результат выполнения программ отправляется из оперативной памяти в постоянную.</p>
<p>Устройство оперативной памяти такого, что при отключении питания данные из нее пропадают.
Постоянная память, наоборот, удерживает записанную в нее информацию при выключенном состоянии.
Поэтому в ней размещают данные, необходимые для работы компьютера: операционная система, программы, файлы конфигурации, справочная информация, результаты выполнения других программ и многое другое.</p>
<p>Постоянная память в компьютере предоставляется устройством под названием <strong>диск</strong>.
Название “диск” пришло от жестких магнитных дисков, которые долгое время оставались единственными устройствами для постоянного хранения данных.
Но сейчас они постепенно вытесняются твердотельными накопителями на микросхемах памяти, называемых иногда SSD-дисками.
Несмотря на это под диском будем подразумевать любое устройство для долговременного хранения данных, а не только жесткий магнитный диск.</p>
<div class="figure align-default">
<a class="reference internal image-reference" href="../_images/hard-drive.jpg"><img alt="../_images/hard-drive.jpg" src="../_images/hard-drive.jpg" style="height: 200px;" /></a>
</div>
<div class="figure align-default">
<a class="reference internal image-reference" href="../_images/solid-state-drive.jpg"><img alt="../_images/solid-state-drive.jpg" src="../_images/solid-state-drive.jpg" style="height: 200px;" /></a>
</div>
<p>В иерархии компьютерной памяти постоянная память располагается в самом низу.
Она предлагает самый большой объем памяти за низкую цену, но доступ к ней самая медленная.
Если в регистры помещается сотня байт, в кеш – сотни килобайты и единицы мегабайт, в оперативной памяти – гигабайты, то в постоянной памяти размещается несколько терабайт данных.
Для многих программ такой объем в принципе неисчерпаем.
Платой за высокие объемы стал медленный доступ к ней.
Доступ в постоянную память медленнее в десятки тысяч раз, чем в оперативную и медленнее в миллионы раз, чем обращение в кэш первого уровня.</p>
<div class="figure align-default">
<img alt="../_images/memory-hierarchy.jpg" src="../_images/memory-hierarchy.jpg" />
</div>
<p>Для чего нужен диск и постоянная память?</p>
<ul class="simple">
<li><p>хранить данные;</p></li>
<li><p>переносить данные на расстояние;</p></li>
<li><p>обмениваться данными программам.</p></li>
</ul>
<p>Запись данных на диск остается единственным способом сохранить большие объемы данных на длительное время.
По оценке <a class="reference external" href="https://www.idc.com">IDC</a> за 2020 год в сети Интернет данных собрано на 59 зеттабайт.
1 зеттабайт примерно соответствует 1 млрд терабайт.
Современный потребительский жесткий диск предлагает объем от 1 до 18 Тб.
Получается, что на каждого жителя планеты Земля приходится по одному диску информации.</p>
<p>Портативные диски используются для переноса данных между компьютерами.
Раньше это было популярной функцией.
На дискетах, CD- и DVD-дисках, а затем флешках переносили данные: рабочие материалы, дистрибутивы программ, музыку и фильмы.
Но сейчас эту функцию взяли на себя высокоскоростной интернет и сервисы хранения и распространения данных.
Музыка и кино доступны не через кассеты и оптические CD- и DVD-диски, а через сервисы youtube, spotify, netflix, социальные сети.
Для передачи данных между собственными компьютерами используют сервисы Яндекс.Диск, Google Диск, Dropbox.</p>
<p>Программы используют постоянную память для обмена данными.
Это чем-то похоже на упомянутое выше перемещение данных, но в пространстве процессов.
Операционная система изолирует исполняемые программы друг от друга и формирует вокруг них подобие виртуальной реальности.
Обмен информацией между программами происходит только через операционную систему.
И самый простой способ обмена из всех – это обмен через файл.
Первая программа создает временный файл и записывает туда данные, а вторая программа считывает их.
Имя файла передается программам при запуске или выбирается заранее и прописывается внутри программы.</p>
</div>
<div class="section" id="id3">
<h2>Накопители информации<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>В качестве диска выступают разнообразные устройства с различным физическим устройством, интерфейсом, габаритами.
На сегодняшний день широко используют жесткие магнитные диски и полупроводниковая флеш-память.
Они отличаются надежностью, стоимостью, скоростью.</p>
<p>Накопитель на жестких магнитных дисках (НЖМД), также известный как жесткий диск, относится к наиболее популярным устройствам.
Он состоит из покрытого ферромагнетиком диска.
Магнитная головка перемещается по радиусу быстро вращающегося диска и считывает и записывает данные, используя управляемое магнитное поле.
Технология достаточно долго развивалась и достигла высоких показателей плотности информации, скорости доступа, надежности при доступной цене.
Плотность информации такова, что на 1 квадратный сантимер помещается 150 Гбит данных.
К недостаткам жесткого диска относится его шумность и выход из строя из-за механического воздействия.
Поэтому он используется только на стационарных устройствах.</p>
<p>На мобильных и малых компьютерах используют полупроводниковую флеш-памяти.
Флеш-память остается основным и единственным конкурентом жесткому диску.
По мере совершенствования полупроводниковой памяти жесткий диск постепенно выталкивается с рынка.
В 2015 году плотность данных на единицу площади во флеш-памяти превысила аналогичные показатели жесткого диска.
Флеш-память работает бесшумно, потребляет меньше электричества, и не подвержен механическим воздействиям.
Скорость записи выше 100-1000 раз по сравнению с жестким диском.
Микросхемы флеш-памяти используются в твердотельных накопителях и картах памяти.
Из-за устойчивости к механическим воздействиям, флеш-память используется в мобильных устройствах.
Но ее недостатком является ограниченное количество циклов перезаписи – в ячейку памяти можно записать от 1000 до 100 000 раз.
На 2020 год, устройство на флеш-памяти стоит дороже, чем жесткий диск.
Поэтому на одной машине используют одновременно два типа диска – HDD и SSD и пользуются преимуществами обоих.</p>
<p>Постепенно из употребления выходят оптические диски.
Их заменяют флешки и сервисы по хранению данных.
Данные, которые раньше переносили на дисках, сейчас можно найти, посмотреть, послушать онлайн без смс и в хорошем качестве.
Оптические диски начали набирать популярность с 1987 года, когда персональные компьютеры стали комплектоваться приводами оптических дисков.
Наибольшую популярностью они пользовались в 1990-е и 2000-е года.
Сохранность данных оставляет желать лучшего.
Диски 20-30 летней давности постепенно распадаются на части и теряют записанную на них информацию.</p>
<p>Следующий накопитель информации, который появился в 1950 годах и используется до сих пор — это ленточный накопитель.
Он как крокодил, доживший до наших дней с эпохи динозавров.
Для записи используется тот же физический принцип, что и в жестких дисках – управляемое магнитное поле.
Но за счет большей площади поверхности и ее компактного хранения, позволяет записывать сверхбольшие объемы данных.
Высокая скорость записи и последовательного считывания, низкая стоимость, делают привлекательной накопитель для архивации и резервного копирования данных.</p>
</div>
<div class="section" id="id4">
<h2>Организация файлов<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Постоянная память вместе с оперативной памятью, процессором и сетевым интерфейсом, относится к ресурсам компьютера.
Доступ программ к постоянной памяти регулирует операционная система.
Она разбивает область постоянной памяти на части и организует предоставляет их программам через абстракцию “файл”.</p>
<p>Участок области постоянной памяти, которой дано имя, называется <strong>файлом</strong>.
Для программы файл выглядит как последовательность байт.
Количество байт в файле (размер файла) не фиксирован и может меняться по требованию.</p>
<p>Память диска поделена на участки одинакового размера, называемых <strong>секторами</strong>.
Обычно сектор состоит из 512 байт.
Контроллер диска работает с памятью на уровне секторов, а не байт.
На аппаратном уровне сектора адресуются, считываются и записываются.</p>
<p>Размер файла меняется в широких пределах.
Он может быть пустым или заполнить весь диск.
Операционной системе не известно, до какого размера разрастется вновь создаваемый файл.
Поэтому файловые данные на диске хранятся во фрагментном представлении.
Фрагментное представление напоминает связанный список – антипод вектора.
Данные списка распределены между узлами, которые разбросаны по разным участкам оперативной памяти.
Узлы связываются и располагаются в нужном порядке указателями.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>list
 |  ┌───────┐   ┌───────┐   ┌───────┐   ┌───────┐
 |  │data:  │   │data:  │   │data:  │   │data:  │
 └─&gt;│next: ─┼──&gt;│next: ─┼──&gt;│next: ─┼──&gt;│next: ─┼──&gt; NULL
    └───────┘   └───────┘   └───────┘   └───────┘
</pre></div>
</div>
<p>Объем сектора слишком мал для современных файлов.
На программном уровне сектора объединяются в кластеры.
Размер кластера кратна размеру сектора и составляет от 2 до 32 Кб или 128 Кб.</p>
<p>Содержимое файла распределяется по нескольким кластерам, разбросанным по диску.</p>
<p>Чем меньше размер кластера, тем больше считывающая головка перемещается по диску и больше пространства для собственных целей забирает файловая система.
Малый размер кластера эффективнее хранит небольшие файлы.</p>
<p>Для большого размера кластера все наоборот.
Считывающая головка меньше передвигается по диску и операции считывания и записи будут эффективнее.
Большим файлам потребуется меньше кластеров для размещения, что уменьшит служебную информацию файловой системы.
Но большие кластеры не эффективны для маленькх файлов (конфигурационных, связанных с веб-страницей статических файлов), так как они не используют большую часть пространства кластера.</p>
<p>Выбор размера кластера – это компромисс между производительностью операций чтения и записи файлов и эффективностью использования дискового пространства.</p>
<p>Базы данных, swap-файл, журнальные файлы (лог-файлы) представлены одним большим файлом и имеют тенденцию расти.
Поэтому для них лучше использовать диски большим размером кластера.
Обратная ситуация в разработке программ, где активно используют текстовый редактор и компилятор.
Проект программы состоит из многих текстовых файлов, а компилятор создает для них объектные файлы.
Здесь требуется диск с кластером малого размера.</p>
</div>
<div class="section" id="id5">
<h2>Каталоги и пути<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Файлы размещаются в каталогах.
Каталоги аналогично файлам обладают именами.
Каталоги могут содержать вложенные каталоги.
В конечном счете получается древовидная структура.
На верхнем уровне располагается <strong>корневой каталог</strong>.
Корневые каталоги уникальны в системе и их именами не получится назвать ни файлы, ни другие каталоги.
В системах UNIX только один такой каталог с именем <code class="docutils literal notranslate"><span class="pre">/</span></code>.
В Windows их может быть несколько с именами <code class="docutils literal notranslate"><span class="pre">a:</span></code>, <code class="docutils literal notranslate"><span class="pre">b:</span></code>, <code class="docutils literal notranslate"><span class="pre">c:</span></code>, <code class="docutils literal notranslate"><span class="pre">d:</span></code>, …, <code class="docutils literal notranslate"><span class="pre">x:</span></code>, <code class="docutils literal notranslate"><span class="pre">y:</span></code>, <code class="docutils literal notranslate"><span class="pre">z:</span></code>.</p>
<div class="figure align-default">
<img alt="../_images/files-and-cataloges.png" src="../_images/files-and-cataloges.png" />
</div>
<p>Положение файла в иерархической структуре задается последовательностью вложенных каталогов, заканчивающаяся названием указываемого файла:
Элементы последовательности (каталоги и файл) разделяются друг от друга символом косой черты (<code class="docutils literal notranslate"><span class="pre">/</span></code>).
Но может использоваться и другой символ.
Например, в Windows раньше использовали символ обратной косой черты (<code class="docutils literal notranslate"><span class="pre">\</span></code>), но в последних версиях поддерживается и косая черта <code class="docutils literal notranslate"><span class="pre">/</span></code>.
Получившаяся строка называется <strong>путем</strong> к файлу.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span><span class="o">/</span><span class="n">ProgramFiles</span><span class="o">/</span><span class="n">Microsoft</span><span class="o">/</span><span class="n">Office</span><span class="o">/</span><span class="n">Word</span><span class="o">/</span><span class="n">word</span><span class="o">.</span><span class="n">exe</span>
</pre></div>
</div>
<p>Путь однозначно определяет положение файла, если он начинается с корневого каталога.
Такой путь называют <strong>полным</strong>.
Но у полного пути есть два недостатка.
Во-первых, из-за его подробности он удлиняется.
Чем глубже в иерархии расположен файл, тем длиннее путь к нему.
Каждый раз набирать такой путь утомительно.
Во-вторых, после перемещения каталога или файла исходный путь становится неверным.</p>
<p>Недостатки полного пути решаются в <strong>относительных путях</strong>.
В них путь к файлу указывают от <strong>текущего каталога</strong>, а не от корневого.</p>
<p>Путь к файлу похож на адрес проживания человека.
Полный адрес начинается со страны и оканчивается квартирой или домом: <code class="docutils literal notranslate"><span class="pre">Россия,</span> <span class="pre">Нижегородская</span> <span class="pre">область,</span> <span class="pre">г.</span> <span class="pre">Саров,</span> <span class="pre">ул.</span> <span class="pre">Духова,</span> <span class="pre">д.</span> <span class="pre">72,</span> <span class="pre">кв.</span> <span class="pre">19.</span></code>
Такой адрес интересен для почтовых отправлений из других стран.
При заполнении документов для государственных учреждений федерального уровня (например, налоговой или пенсионной) название страны пропускают.
Для документов муниципального уровня часто пропускают область, превращая адрес в <code class="docutils literal notranslate"><span class="pre">г.</span> <span class="pre">Саров,</span> <span class="pre">ул.</span> <span class="pre">Духова,</span> <span class="pre">д.</span> <span class="pre">72,</span> <span class="pre">кв.</span> <span class="pre">19</span></code>.
При вызове скорой пропустят город и продиктуют адрес, начиная с улицы.
У организаций из примеров выше есть своя область влияния.
Каждый раз указывать адрес этой области будет излишне.
Аналогичный феномен есть и у программ применительно к иерерхии файлов, которая называется текущим или рабочим каталогом.
Но в отличие от примера выше с адресами, текущий каталог не фиксирован и может меняться.</p>
<p>С каждой запущенной программой связан текущий каталог.
Есть путь к файлу не начинается с корневого каталога, то считается, что он начинается с текущего.
Такой путь, как уже написали выше, называется относительным.
Для получения полного пути, к относительному пути спереди добавляют путь к текущему каталогу:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">полный</span> <span class="n">путь</span> <span class="n">к</span> <span class="n">файлу</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">путь</span> <span class="n">к</span> <span class="n">текущему</span> <span class="n">каталогу</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">&lt;</span><span class="n">относительный</span> <span class="n">путь</span> <span class="n">к</span> <span class="n">файлу</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Относительный путь решает обе проблемы полного пути.
Пути к файлам и каталогам укорачиваются за счет того, что общая часть путей выносится в текущий каталог.
Относительные пути остаются верными и после перемещение текущего каталога в иерархии.
Достаточно знать полный путь к перенесенному каталогу и установить его как текущий.</p>
<p>Для относительных путей вводят специальные обозначения для указания текущего и родительского каталогов.
Текущий каталог обозначают символом точка (<code class="docutils literal notranslate"><span class="pre">.</span></code>), а родительский, т.е. каталог уровнем выше, – двумя точками (<code class="docutils literal notranslate"><span class="pre">..</span></code>).</p>
<p>Обозначение родительского каталога позволяет указывать файлы, расположенные за пределами текущего каталога.
Пусть текущий каталог указывает на каталог с проектом <code class="docutils literal notranslate"><span class="pre">lab1</span></code>.
Тогда <code class="docutils literal notranslate"><span class="pre">../lab2/main.c</span></code> указывает на файл <code class="docutils literal notranslate"><span class="pre">main.c</span></code> в соседнем с <code class="docutils literal notranslate"><span class="pre">lab1</span></code> каталоге <code class="docutils literal notranslate"><span class="pre">lab2</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">projects</span>
  <span class="o">|-</span><span class="n">lab1</span>       <span class="o">&lt;====</span> <span class="n">текущий</span> <span class="n">каталог</span>
  <span class="o">|</span>  <span class="o">|-</span><span class="n">main</span><span class="o">.</span><span class="n">c</span>
  <span class="o">|</span>  <span class="o">|-</span><span class="n">task</span><span class="o">.</span><span class="n">html</span>
  <span class="o">|-</span><span class="n">lab2</span>
  <span class="o">|</span>  <span class="o">|-</span><span class="n">main</span><span class="o">.</span><span class="n">c</span>  <span class="o">&lt;====</span> <span class="o">../</span><span class="n">lab2</span><span class="o">/</span><span class="n">main</span><span class="o">.</span><span class="n">c</span>
  <span class="o">|</span>  <span class="o">|-</span><span class="n">out</span><span class="o">.</span><span class="n">txt</span>
  <span class="o">|-</span><span class="n">lab3</span>       <span class="o">&lt;====</span> <span class="o">../</span><span class="n">lab3</span><span class="o">/</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Возникает вопрос: когда в путях используют явное обозначение <code class="docutils literal notranslate"><span class="pre">.</span></code> текущего каталога?
Понятно, если путь указывается не с корневого каталога, то он считается относительным.
Имена корневых каталогов уникальны в системе, поэтому не получится спутать относительные и полные пути.
Но в некоторых случаях необходимо задать полное имя к файлу.
Проще это сделать, используя синоним текущего каталога <code class="docutils literal notranslate"><span class="pre">.</span></code>, чем набивать полный путь: <code class="docutils literal notranslate"><span class="pre">./myfile</span></code> эквивалентна <code class="docutils literal notranslate"><span class="pre">/home/skt/myfile</span></code> при текущем каталоге <code class="docutils literal notranslate"><span class="pre">/home/skt</span></code>.</p>
<div class="admonition- admonition">
<p class="admonition-title">Пример с указанием полного пути</p>
<p>Интерпретатор bash запускает системные утилиты по имени.
Полные пути к запускаемым файлам формируются не из текущего каталога и имени утилиты, а из каталогов, указанных в переменной среды <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.
Если вам понадобится запустить собственную программу <code class="docutils literal notranslate"><span class="pre">myutility</span></code> из текущего каталога, то это можно сделать только командой <code class="docutils literal notranslate"><span class="pre">./myutility</span></code>.</p>
</div>
</div>
<div class="section" id="id6">
<h2>Метаданные файла<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>С файлом, кроме данных, связана дополнительная информация, называемая <strong>метаданными</strong>.
Состав метаданных отличается в разных файловых системах.</p>
<ul class="simple">
<li><p>имя с расширением;</p></li>
<li><p>метки времени;</p></li>
<li><p>атрибуты;</p></li>
<li><p>права доступа.</p></li>
</ul>
<p>Имя файла в большинстве случаев представлена строкой из печатных символов с исключением служебных символов.
В имени файла выделяют <strong>расширение</strong>, которая располагается в конце и отделяется от остальной частьи точкой.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="o">.</span><span class="n">c</span>
<span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span>
<span class="n">image</span><span class="o">.</span><span class="n">png</span>
<span class="n">index</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p>Расширение указывает на тип файла, что именно в нем содержится:
По расширению пользователь или система определяет, в какой программе открыть файл и как интерпретировать его содержимое.
Примеры расширений:</p>
<ul class="simple">
<li><p>.txt плоский текст.</p></li>
<li><p>.png, .jpg изображения в форматах png, jpg.</p></li>
<li><p>.h, .c исходные коды программ на языке программирования Си.</p></li>
<li><p>.so разделяемая библиотека.</p></li>
</ul>
<p>Имя файла должно быть уникальным в пределах каталога, т.е. в одном каталоге не могут содержаться два файла с одинаковым именем.
Windows в именах файлов (и не только в них) не различает строчные и заглавные буквы: символы <code class="docutils literal notranslate"><span class="pre">a</span></code> и <code class="docutils literal notranslate"><span class="pre">A</span></code> считаются совпадающими.
Такие имена называют <strong>регистронезависимыми</strong>.
В системах UNIX ситуация обратная, и символы в разных регистрах отличаются.
Каталоги <code class="docutils literal notranslate"><span class="pre">Мои</span> <span class="pre">Документы</span></code> и <code class="docutils literal notranslate"><span class="pre">Мои</span> <span class="pre">документы</span></code> в Windows относятся к одному каталогу, а в UNIX – к разным.
Это следует помнить.</p>
<div class="admonition- admonition">
<p class="admonition-title">Ошибка сборки программи из-за имен файлов</p>
<p>Частая ошибка при сборке программ в UNIX, которые собираются в Windows, это отсутствие подключаемого заголовочного файла.
Файл назван как <code class="docutils literal notranslate"><span class="pre">Xxxxx.h</span></code>, а в исходном коде подключается как <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;xxxxx.h&quot;</span></code>.</p>
</div>
<p>Не все символы могут быть использованы в именах файлов.
В Windows для использования в именах файлов (и каталогов) запрещены символы с кодами 0-31 и печатные символы <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">\</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>.
Также именам файлов (и каталогов) не разрешено оканчиваться на пробел и точку.</p>
<p>Рекордсменом по наименьшим запретам выступает UNIX, где только 2 символа запрещены из 256.
Это разделитель в путях <code class="docutils literal notranslate"><span class="pre">/</span></code> и нулевой символ <code class="docutils literal notranslate"><span class="pre">\0</span></code> (признак окончания строки в языке программирования Си).
Остальные 254 символа разрешены, даже управляющие символы из таблицы ASCI.</p>
<p>К каждому файлу привязаны следующие метки времени:</p>
<ul class="simple">
<li><p>время создания – когда был создан файл;</p></li>
<li><p>время доступа – когда в последний раз открывали файл;</p></li>
<li><p>время модификации – когда в последний раз изменяли содержимое файла;</p></li>
<li><p>время изменения – когда в последний раз изменяли метаданные файла.</p></li>
</ul>
<p>По названиям меток понятно, что они показывают.
Запуск исполняемого файла связан с его считыванием из диска в оперативную память.
Поэтому для программы метка времени доступа показывает, когда в последний раз она была запущена.</p>
<p>Аналогичные метки привязаны к каталогам.
Для каталога время доступа обновляется, когда просматривается его содержимое.
Времена изменения и модификации каталога привязаны к аналогичным меткам последнего измененного файла внутри каталога.</p>
<p>Метки времени вместе с утилитами для поиска и сортировки позволяют ответить на многие вопросы и решить важные задачи.</p>
<ul class="simple">
<li><p>Как найти файл с неизвестным именем, но примерно известным временем создания и модификации?</p></li>
<li><p>Когда в последний раз меняли конфигурацию программы?</p></li>
<li><p>Взламывали ли систему?</p></li>
<li><p>Выполнять ли резервное копирование файла или он не менялся с прошлого раза?</p></li>
</ul>
<ul class="simple">
<li><p>Скрытый.   Стандартные средства просмотра не будут отображать файл.</p></li>
<li><p>Только для чтения. Файл нельзя изменить.</p></li>
<li><p>Системный. Файл важен для функционирования системы, поэтому не должен изменяться.</p></li>
<li><p>Архивный.  Файл изменен с последнего резервного копирования.</p></li>
<li><p>Сжатый.    Файл на диске хранится в сжатом виде.</p></li>
<li><p>Зашифрованный. Файл хранится на диске в зашифрованном виде.</p></li>
<li><p>Проиндексированный. Содержимое файла будет использовано для формирования поискового индекса – структуры для ускорения поиска.</p></li>
</ul>
<p>Одна из функций файловой системы – это защита файлов и каталогов от других пользователей.
Другим пользователям ограничиваются в правах: им запрещают читать и записывать в файлы, изменять атрибуты файлов и создавать файлы.
rwx - чтение, запись, выполнение.</p>
<ul class="simple">
<li><p>r – право открывать файл. Для каталога бит дает право получать его содержимое, т.е. просмотреть список файлов.</p></li>
<li><p>w – право записывать файл. Для каталога бит дает право изменить список файлов, т.е. удалять, создавать и перемещать файлы.</p></li>
<li><p>x – право на выполнение файла. Для каталога бит дает право</p></li>
</ul>
<p>Право на выполнение могут иметь как двоичные, так и текстовые файлы.
Исполняемый двоичный файл отправляется на процессор.
Исполняемый текстовый файл рассматривается как содержащий инструкции для интерпретатора.
То, какой интерпретатор нужно использовать, требуется указать в первой строке файла в формате <code class="docutils literal notranslate"><span class="pre">#!&lt;путь</span> <span class="pre">к</span> <span class="pre">интерпретатору&gt;</span></code>.
В качестве интерпретаторов могут быть <code class="docutils literal notranslate"><span class="pre">sh</span></code>, <code class="docutils literal notranslate"><span class="pre">bash</span></code>, <code class="docutils literal notranslate"><span class="pre">python</span></code>, <code class="docutils literal notranslate"><span class="pre">perl</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="c1">#!/bin/bash</span>
<span class="c1">#!/usr/bin/python</span>
<span class="c1">#!/usr/bin/perl</span>
</pre></div>
</div>
<p>Чтобы можно было удалить файл, необходимо иметь установленный атрибут <code class="docutils literal notranslate"><span class="pre">w</span></code> в файле и его родительском каталоге.
Потому что удаление файла означает исключение файла из списка файлов каталога.</p>
<p>Категории пользователей:</p>
<ol class="simple">
<li><p>для владельца</p></li>
<li><p>для группы пользователей</p></li>
<li><p>для остальных пользователей.</p></li>
</ol>
<p>В общедоступных каталогах всем пользователям и программам разрешают создавать и удалять файлы.
Например, это каталог <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> с временными файлами.
Любой программе позволено создать файл.
Но так как каталогу установлено разрешение на запись <code class="docutils literal notranslate"><span class="pre">w</span></code>, то получается, что любой пользователь может удалить данные остальных пользователей.
Чтобы такого не происходило, используется sticky-бит.
Он указывает каталогу, что его файлы разрешается удалять только их владельцам.</p>
</div>
<div class="section" id="id7">
<h2>Файлы-ссылки<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>В файловой системе существуют специальные файлы, которые вместо того, чтобы содержать данные, указывают на другие файлы.
Такие файлы называют <em>ссылками</em>.
Имя ссылки может отличаться от имени файла, на который она ссылается.
Таким образом ссылки вводят другое имя файлу.
Ссылка может разместиться в другом каталоге.
Существуют два типа ссылок: символьные и жесткие.</p>
<p>Жесткая ссылка указывает на содержимое файла, изменяя только ее имя.</p>
<p>Символьная ссылка указывает на имя другого файла, называемого целевым.
Обращение к ней перенаправляется к целевому файлу.
В отличие от жесткой ссылки, она может ссылаться на каталоги, несуществующие файлы, файлы и каталоги из другой файловой системы.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Символьные и жесткие ссылки вносят в древовидную структуру файловой системы горизонтальные связи.</p>
</div>
<p>Рассмотрим примеры, когда ссылки помогают решить проблемы, возникающие в программировании.</p>
<p>Если файл или каталог по каким-то причинам имеет неудобное имя или расположение, а размер не позволяет их скопировать, то нужно воспользоваться ссылкой.
Ссылка позволит разместить файл в нужном месте и нужным именем.</p>
<p>Для сборки программ могут потребоваться конкретные файлы и каталоги, которые были зашиты в сборочных файлах, вместо того, чтобы быть вынесенными как входные параметры.
Такое происходит, когда разработчик развивал программу в своем специфическом программном окружении.
При передаче программы другому разработчику, ему также придется настроить аналогичное окружение.
Для настройки окружения он может использовать символьные ссылки на файлы и каталоги.</p>
<p>Символьные ссылки используют в процессе обновления программ.
Программы проектируются таким образом, чтобы использовать функции из разделяемых библиотек.
Со временем в разделяемые библиотеки вносят изменения: исправляют ошибки, улучшают существующие или добавляют новые функции.
Изменения программного кода отображаются в номерах версии, которая состоит из трех чисел, разделенных точкой.
В имени файла с библиотекой прописана ее версия.
Если библиотека обновляется, в том же каталоге появляется файл с другой версией в названии.
И то, какая библиотека является текущей, показывает символическая ссылка.
Программа, которой необходима разделяемая библиотека, загружает ее по символической ссылке.</p>
</div>
<div class="section" id="unix">
<h2>Стандартные каталоги в UNIX<a class="headerlink" href="#unix" title="Permalink to this headline">¶</a></h2>
<p>В системах UNIX состав каталогов верхнего уровня и их назначение закреплены стандартом FHS (Filesystem Hierarchy Standard).
Поддержка стандарта добровольное желание
Последний раз документ обновлен в 2015 году и имеет версию 3.0.
Содержимое стандарта можно просмотреть командами <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">hier</span></code> и <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">file-hierarchy</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/bin</span></code>
Основные утилиты, необходимые для работы всем пользователям (обычным и суперпользователю).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sbin</span></code>
Системные утилиты для администрирования системы.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/lib</span></code>
Программные библиотеки, необходимы для программ из <code class="docutils literal notranslate"><span class="pre">/bin</span></code>, <code class="docutils literal notranslate"><span class="pre">/sbin</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/etc</span></code>
Конфигурационные файлы, относящиеся к системе.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/home</span></code>
Домашние каталоги пользователей системы.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/root</span></code>
Домашний каталог суперпользователя.
Каталог <code class="docutils literal notranslate"><span class="pre">/home</span></code> может быть примонтированным и физически располагаться на другом диске.
Если диск выйдет из строя, то суперпользователь не сможет обслуживать машину.
В целях устойчивости системы, домашний каталог суперпользователя размещают ближе к системе – в корневой каталог.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/boot</span></code>
Файлы для загрузки операционной системы.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/dev</span></code>
Файлы устройств.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/media</span></code>
Точки монтирования для сменных носителей CD-ROM, DVD-ROM.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/mnt</span></code>
Временно монтируемые файловые системы.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/opt</span></code>
Дополнительное программное обеспечение.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/proc</span></code>
Виртуальная файловая система с информацией о состоянии операционной системы и процессов в виде файлов.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/run</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/srv</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/usr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/tmp</span></code>
Временные файлы.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/var</span></code>
Изменяемые файлы.
В отличие от временных файлов из <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> файлы в <code class="docutils literal notranslate"><span class="pre">/var</span></code> остаются после перезагрузки системы.</p></li>
</ul>
</div>
<div class="section" id="id8">
<h2>Файловая система<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Представьте себе, что у вас есть непрерывная область памяти фиксированного размера.
Каким образом вы разместите на ней файлы с их данными, именами и атрибутами?
Как представите каталоги и вложенности файлов и каталогов в другие каталоги?</p>
<p>Усложним задачу, добавив, что иерархическая структура вложенностей каталогов в файлы не статична, а меняется со временем.
Размеры файлов также меняются: увеличиваются или уменьшаются.</p>
<p>Наша задача похожа на проектирование структур данных моделируемого объекта.
Она решается средствами высокоуровневого языка программирования в терминах типов данных, указателей, записей, массивов, таблиц, списков и остального.
Но есть отличия.
Во-первых, нам не доступен менеджер памяти, который бы выделял блоки произвольного размера и решал задачу их размещения в памяти.
Во-вторых, исходная область памяти адресуется не по байтам, а по блокам – наборами из 512 (или другого размера) байтов.
В-третьих, блоки, из которых состоит память, могут выходить из строя и уже не смогут хранить данные.
И было бы правильно их обходить.</p>
<p>Файловая система должна быть устойчивой к сбоям: неожиданным отключениям питания и краху операционной системы.</p>
<p>Файловая система не должна ограничивать размер файла, длину имени файла, длину пути к файлу, уровень вложенности, количество файлов.
Она должна одинаково эффективно хранить и малые и большие файлы.
При этом не ограничивать скорость доступа к файлам.</p>
<p>Важная задача операционной и файловой систем – это обеспечение безопасности данных на диске.
Ограничивать доступ к файлам и каталогам одним и разрешать другим пользователям.
Гибко управлять доступом к файлам – разрешать и запрещать чтение и запись данных файла, изменение атрибутов.
Следить за изменениями файлов.
Задачи выше и многое остальное решает <strong>файловая система</strong>:</p>
<ul class="simple">
<li><p>журналирование;</p></li>
<li><p>дефрагментация;</p></li>
<li><p>шифрование;</p></li>
<li><p>сжатие данных;</p></li>
<li><p>проверка контрольных сумм;</p></li>
</ul>
</div>
<div class="section" id="id9">
<h2>Журналирование<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Наверное у каждого неожиданно выключался компьютер из-за отключения электричества, ошибки в операционной системе или отказе оборудования.
При последующем включении система сообщает об аварийном завершении и предлагает проверку диска.
Откуда ей известно о завершении и зачем понадобилась проверка диска?</p>
<p>Сложная структура файловой системы не позволяет операциям над ней быть атомарными.
Вместо этого операции состоят из нескольких последовательных модификаций структуры.
Если произойдет сбой в середине операции, то файловая система окажется в несогласованном состоянии.</p>
<p>Аварийные завершения определяются следующим образом.
При инициализации файловой системы на диск устанавливают метку в определенном месте.
Метка сбрасывается при плановом завершении, но не успевает это сделать при аварийном.
Следующая загрузка системы увидит несброшенную метку и сообщит об этом пользователю.</p>
<p>Чтобы исправить ошибку и сохранить данные, запускают утилиту для проверки диска.
Главное вовремя исправить ошибку, так как последующие изменения несогласованных данных могут привести к потере всех данных.</p>
<p>Один из способов увеличения надежности файловой системы является <strong>журналирование</strong>.
При журналировании изменения файловой системы сначала записываются в специальный файл, называемый журналом.
В определенный момент времени (по истечению некоторого времени, заполненности журнала) изменения из журнала применяются над диском.
Если изменения данных на диске прошли успешно, то из журнала изменение удаляется.
При экстренном выключении компьютера, незафиксированные на диске изменения остаются в журнале.</p>
<div class="figure align-default">
<img alt="../_images/filesystem-journaling.gif" src="../_images/filesystem-journaling.gif" />
</div>
<p>В зависимости от того, изменения каких данных записываются в журнал, выделяют три стратегии журналирования.</p>
<ul class="simple">
<li><p><strong>режим обратной связи</strong> в журнал записываются только метаданные;</p></li>
<li><p><strong>режим упорядочивания</strong> сначала на диск записываются данные, а затем в журнал метаданные;</p></li>
<li><p>В <strong>режиме данных</strong> в журнал записываются и данные и метаданные файла.</p></li>
</ul>
</div>
<div class="section" id="id10">
<h2>Дефрагментация диска<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>Те, кто пользуются файлом, не сталкиваются с его фрагментарностью.
Она скрыта операционной системой.
Но фрагментарность косвенно дает знать о себе программам.</p>
<p>Данные из жесткого диска считывает магнитная головка, позиционируемая в радиальном направлении электрическим двигателем.
Если фрагменты файла не идут подряд, а разбросаны по диску, то головке приходится часто перемещаться из одной дорожки на другую.
Это уменьшает производительность файловых операций чтения и записи.
Процесс перестановки фрагментов файла таким образом, чтобы они шли подряд, называется <strong>дефрагментация</strong>.</p>
<p>Для флеш-памяти ситуация с фрагментацией противоположная.
Запись в микросхеме производится высоким напряжением электромагнитного поля.
Это изнашивает ячейки памяти и уменьшает их срок службы.
Производителем, в зависимости от технологии, гарантируется 1000, 10 000 или 100 000 циклов перезаписи.
Поэтому файловые системы, ориентированные на флеш-память, распределяют нагрузку по диску, стараясь равномерно его изнашивать.
Доступ к разным частям флеш-памяти выполняется за одинаковое время, поэтому фрагментация файлов не вызывает проблем.
А наоборот, решает их.</p>
</div>
<div class="section" id="fat">
<h2>Файловая система FAT<a class="headerlink" href="#fat" title="Permalink to this headline">¶</a></h2>
<p>Обратим наше внимание на семейство файловых систем FAT, как на самую простую из существующих.
Это одна из немногих технологий Microsoft, подробности о которой известны.
Было бы глупо пройти мимо такого легко доступного сокровища.</p>
<p>Файловую систему FAT разработала Microsoft в 1977 году для использования на дискетах.
Затем ее адаптировали под жесткий диск персонального компьютера с операционной системой DOS и ранних версий Windows.
В операционной системе Windows она использовалась до тех пор, пока не была заменена более современной NTFS.</p>
<p>Несмотря на давность и замену в Windows, FAT никуда не исчезла.
Ее внутренняя структура проста в реализации, поэтому используется в маломощных устройствах.
FAT, начиная с 1998 года, является стандартом для цифровых фотоаппаратов.
Из-за эффективности на малых размерах дисков ее используют на картах памяти, флешках и для обмена информацией между различными файловыми системами.</p>
<p>FAT – это не одна файловая система, а семейство из FAT12, FAT16, FAT32 и exFAT.
По мере увеличения размеров диска, FAT эволюционировала – увеличилось количество адресуемых кластеров за счет увеличения разрядности целых чисел, которая указана в названиях.</p>
<p>FAT12 использует 12-разрядные целые для индексирования кластеров и позволяет адресовать до <span class="math notranslate nohighlight">\(2^{12}\)</span> (4096) кластеров.
При 4 Кб кластере поддерживает до 16 Мб пространства.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>12-битное целое число состоит из полутора байт.
В FAT считается, что байты на диске располагаются от младшего байта к старшему.
Поэтому серия из трех байт <code class="docutils literal notranslate"><span class="pre">0x16</span> <span class="pre">0xAC</span> <span class="pre">0x73</span></code> интерпретируется как <code class="docutils literal notranslate"><span class="pre">0x16C</span> <span class="pre">0xA73</span></code>.</p>
</div>
<p>FAT16 использует 16-разрядные (двухбайтовые) целые и адресует до <span class="math notranslate nohighlight">\(2^{16}\)</span> кластеров.</p>
<p>FAT32, несмотря на название, использует только 28 бит на адресацию кластеров.
Этого было достаточно на момент ее разработки.
Старшие 4 бита зарезервированы на будущие реализации и должны быть нулевыми.</p>
<p>FAT обладает многими достоинствами.</p>
<ul class="simple">
<li><p>Она проста в реализации, что позволило ей распространится на маломощных устройствах.</p></li>
<li><p>FAT эффективно использует малый размер памяти диска.</p></li>
<li><p>exFAT, продолжение FAT для полупроводниковой флеш-памяти, бережно использует ячейки памяти, уменьшая их износ.</p></li>
</ul>
<p>Название FAT система получила от ключевой используемой структуры – таблицы размещения файлов (File Allocation Table).
В ней прописывается цепочка кластеров, из которых состоит файл.</p>
<p>Рассмотрим файловую структуру FAT на примере FAT32.
Область диска с файловой системой условно поделена на три части:</p>
<ul class="simple">
<li><p>служебную область;</p></li>
<li><p>таблицу размещения файлов;</p></li>
<li><p>область данных.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">-------------------</span><span class="n">x</span><span class="o">---------------------------</span><span class="n">x</span><span class="o">----------------</span><span class="n">x</span>
<span class="o">|</span> <span class="n">Служебная</span> <span class="n">область</span> <span class="o">|</span> <span class="n">Таблица</span> <span class="n">размещения</span> <span class="n">файлов</span> <span class="o">|</span> <span class="n">Область</span> <span class="n">данных</span> <span class="o">|</span>
<span class="n">x</span><span class="o">-------------------</span><span class="n">x</span><span class="o">---------------------------</span><span class="n">x</span><span class="o">----------------</span><span class="n">x</span>
</pre></div>
</div>
<p>Служебная область содержит информацию, относящуюся к файловой системе в целом.
В последующем она понадобится для разбора записанных структур.
В ней содержится указание, что используется конкретный тип файловой системы и его параметры: размер и количество кластеров.</p>
<p>Дополнительно, служебная область FAT32 содержит интегральную информацию о состоянии файловой системы:</p>
<ul class="simple">
<li><p>количество свободных кластеров;</p></li>
<li><p>номер последнего выделенного кластера.</p></li>
</ul>
<p>В области данных сохраняется вся остальная информация: данные и метаданные файлов и файловой системы.</p>
<p>Таблица размещения файлов представляет собой обычный массив целых чисел.
Размер массива соответствует количеству кластеров в области данных.
Элементы массива, целые числа с разрадяностью 12, 16 и 32 в зависимости от типа файловой системы (FAT12, FAT16 и FAT32) обозначают следующее:</p>
<ul class="simple">
<li><p>номер следующего кластера в цепочке;</p></li>
<li><p>метка конца цепочки кластеров;</p></li>
<li><p>метка сбойного кластера;</p></li>
<li><p>метка свободного кластера.</p></li>
</ul>
<p>Цепочка кластеров, из которых состоит файл, хранится в таблице размещения файлов.
Чтобы восстановить цепочку, достаточно знать номер первого кластера файла.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>main.c = {32, 16, 20, 21, 22, 23, 24}
module.h = {6, 41, 13, 5, 7, 8, 9}
module.c = {2, 4, 10, 11, 12, 14, 15, 30, 31, 33}

    0   1   2   3   4   5   6   7   8   9
  ┌╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┬╌╌╌┐
0 | x | x | 4 | - | 10| 7 | 41| 8 | 9 | s |
  ├╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┤
1 | 11| 12| 14| 5 | 15| 30| 20| - | - | - |
  ├╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┤
2 | 21| 22| 23| 24| s | - | - | - | - | - |
  ├╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┤
3 | 31| 33| 16| s | - | - | - | - | - | - |
  ├╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┼╌╌╌┤
4 | - | 13| - | - | - | - | - | - | - | - |
  └╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┴╌╌╌┘
</pre></div>
</div>
<p>Пока понятно, как хранятся данные файла.
Но как сохраняются каталоги и метаинформация о файле?</p>
<p>Для описания файла используется 32-байтная <strong>файловая запись</strong>:</p>
<div class="figure align-default">
<img alt="../_images/fat32-file-entry.svg" src="../_images/fat32-file-entry.svg" /></div>
<p>Запись содержит метаинформацию о файле.</p>
<p>Имя файла содержится в поле <code class="docutils literal notranslate"><span class="pre">DIR_Name</span></code> размером всего 11 байт.
Первые восемь символов относятся к имени, а остальные три – к расширению.
Точка явно не хранится.
Если имя короче восьми символов, то неиспользуемые символы устанавливаются в пробелы.
Наверное, отсюда и появился запрет в Windows на пробелы в концах имен файлов.</p>
<p>11 символов на имя не достаточно для современных файловых систем.
Поэтому появилось расширение FAT – VFAT (Virtual FAT), которая не нарушая обратной совместимости, добавляет поддержку длинных имен в кодировке UTF-16LE.
О ней речь пойдет ниже.</p>
<p>Номер первого кластера файла прописывается в полях <code class="docutils literal notranslate"><span class="pre">DIR_FSTClusLO</span></code>, <code class="docutils literal notranslate"><span class="pre">DIR_FstClusHI</span></code>, которые вместе дают 4 байта.</p>
<p>Размер файла прописывается в поле <code class="docutils literal notranslate"><span class="pre">DIR_FileSize</span></code>.
Достаточно знать количество кластеров, размер кластера и файла, чтобы вычислить конец файла в последнем кластере.</p>
<p>Файловая система поддерживает следующие метки времени с различной точностью.</p>
<ul class="simple">
<li><p>дата и время создания файла (поля <code class="docutils literal notranslate"><span class="pre">DIR_CrtDate</span></code>, <code class="docutils literal notranslate"><span class="pre">DIR_CrtTime</span></code> и <code class="docutils literal notranslate"><span class="pre">DIR_CrtTimeTenth</span></code>) с точностью до десятков миллисекунд благодаря 6 байтам на всю метку;</p></li>
<li><p>дата и время изменения файла (поля <code class="docutils literal notranslate"><span class="pre">DIR_WrtDate</span></code> и <code class="docutils literal notranslate"><span class="pre">DIR_WrtTime</span></code>) с точностью до 2 секунд;</p></li>
<li><p>дата последнего доступа к файлу (поле <code class="docutils literal notranslate"><span class="pre">DIR_LstAccDate</span></code>).</p></li>
</ul>
<p>Для FAT характерны 4 атрибута, прописанных в однобайтовом поле <code class="docutils literal notranslate"><span class="pre">DIR_Attr</span></code>:</p>
<ul class="simple">
<li><p>“только для чтения”;</p></li>
<li><p>“скрытый”;</p></li>
<li><p>“системный”;</p></li>
<li><p>“архивный”.</p></li>
</ul>
<p>Каталог в FAT представлен в виде файла.
В кластерах каталога размещаются файловые записи на файлы и другие каталоги.</p>
<p>Файловая запись каталога выделяется от файла тем, что <code class="docutils literal notranslate"><span class="pre">DIR_FileSize</span></code> (размер файла) инициализирован нулем и установлен четвертый бит поля <code class="docutils literal notranslate"><span class="pre">DIR_Attr</span></code>.</p>
<p>Есть специальный каталог, который присутствует всегда, – это корневой.
Корневой каталог начинается со второго кластера в области данных.</p>
<p>Каталоги дополнительно содержат файловые записи на самого себя с именем <code class="docutils literal notranslate"><span class="pre">.</span></code> и родительского каталога с именем <code class="docutils literal notranslate"><span class="pre">..</span></code>.</p>
<p>Поле <code class="docutils literal notranslate"><span class="pre">DIR_Name</span></code> в файловой записи состоит только из 11 байт, что ограничивает имя файла до формата <code class="docutils literal notranslate"><span class="pre">8.3</span></code> и 8-битной кодовой страницы.
Расширение VFAT добавляет в файловую систему поддержку длинных имен в двухбайтной кодировке символов UNICODE, не нарушая обратной совместимости с более поздними типами систем.
Для этого, вводится LFN-запись, совпадающая по размеру с файловой записью.
Некоторые ее поля имеют такие значения, что запись игнорируется старыми версиями файловых систем.
Таким образом, один файл может иметь два имени – короткое и длинное.</p>
<div class="figure align-default">
<img alt="../_images/fat32-lfn-entry.svg" src="../_images/fat32-lfn-entry.svg" /></div>
<p>Большая часть LFN-записи отведена под хранение имени – это поля <code class="docutils literal notranslate"><span class="pre">LDIR_Name1</span></code>, <code class="docutils literal notranslate"><span class="pre">LDIR_Name2</span></code> и <code class="docutils literal notranslate"><span class="pre">LDIR_Name3</span></code>.
Вместе они составляют 26 байт, что составляет 13 двухбайтных символов.
Если длина имени превышает 13 символов, то добавляется еще LFN-запись, нумерация которой содержится в поле <code class="docutils literal notranslate"><span class="pre">LDIR_Ord</span></code>.
Максимальная поддерживаемая длина имени составляет 255 символов.</p>
<div class="section" id="id11">
<h3>Файловые операции в FAT<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Первое, что следует сделать перед работой с диском, это распознать тип его файловой системы.
Тип определяется автоматически по сигнатуре – специфическими значениями в определенных участках памяти.
В зависимости от типа файловой системы выбираются процедуры для работы с ней.</p>
<p>Считывание файловой системы состоит в последовательном разборе трех областей: служебной, таблицы размещения файлов и области данных.
Информация, полученная от разбора предыдущей области, позволяет разобрать следующую.</p>
<p>Информация из служебной области позволяет вычислить размер и расположение таблицы размещения файлов.
Первый кластер корневого каталога расположен во втором кластере области данных.
Начиная с корневого каталога расположен во втором кластере области данных.
Начиная с корневого каталога и используя таблицу, раскручивается вся иерархия файловой системы.</p>
<p>Удаление файла (каталога) состоит из двух шагов:</p>
<ul class="simple">
<li><p>стирание файловой записи удаляемого файла: первый байт записи инициализируется числом 0xE5, означающей, что запись свободна.</p></li>
<li><p>Стирание всех LFN-записей, связанных с удаляемым файлом.</p></li>
<li><p>Освобождение кластеров из-под удаляемого файла из таблицы размещения файлов.
Ячейки в таблице отмечаются маркером свободного кластера.</p></li>
</ul>
<p>Под форматированием диска подразумевается приведение таблицы в исходное состояние.
Ячейки таблицы (кроме первых двух, являющихся служебными) инициализируются маркером свободного кластеров.
Как видим, область данных не трогается.
Сбрасывая содержимое таблицы размещения файлов мы теряем все цепочки кластеров.</p>
<p>Перемещение файла состоит из двух шагов – удаления файловой записи из одной таблицы каталога и копирование в другую.</p>
<p>Добавление нового файла состоит из трех шагов:</p>
<ul class="simple">
<li><p>создание файловой записи в таблице каталога;</p></li>
<li><p>выделение цепочки кластеров в таблице размещения файлов;</p></li>
<li><p>копирование данных файла в кластеры.</p></li>
</ul>
<p>Таблица размещения файлов является ключевой структурой, которой известно расположение файлов на диске.
В случае выхода ее из строя вся файловая система придет в негодность.
Поэтому, для надежности, таблицу дублируют, а копии размещают рядом.</p>
</div>
</div>
<div class="section" id="id12">
<h2>Заключение<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<!--
% Зачем нам файловая система
Разработчику необходимо знать про внутреннее устройство файловой системы:
* чтобы создавать программы, эффективно работающие с файлами;
* познакомится примером сериализации сложных структур данных.

% Зачем нужно изучать внутреннее устройство ФС
Внутреннее устройство файловой системы похож на формат бинарных файлов.
Перед разработчиком программы рано или поздно встает задача -- сохранять данные приложения в файл или, что то же самое, в поток байтов, для их последующей передачи и обратной загрузки.
Процесс преобразования данных в памяти в поток байтов называется **сериализация**.

Данные приложения представлены в виде переплетения разных типов объектов и чем-то похожи на файловую систему.

Существует два альтернативных способа решить эту задачу -- воспользоваться текстовым или двоичным форматом.

Текстовый формат удобен тем, что он понятен человеку.
Для упрощения работы можно воспользоваться существующими универсальными форматами json, yaml или xml.
Но есть существенный недостаток текстовых форматов для больших объемов данных: разбор выполняется долго, а размер файла будет большим.

С увеличением объемов данных возникает потребность перейти на двоичный формат.
Упростить эту работу можно, если воспользоваться готовыми инструментами, например [Protocol Buffers]() от Google или двоичным форматом XML.
Но лучше конечно же, сделать все самому.

% Обратная совместимость файлов
Со временем приложение развивается и в ней появляются дополнительные возможности.
Обновится формат файла и изменится функция загрузки файла в приложение.
И тут появится проблема с обратной совместимостью: новая функция не захочет загружать предыдущий формат файла.

% Кроссплатформенность

% Скорость загрузки
Вторая проблема -- загрузка данных из файла будет недостаточной для больших объемов данных.
Двоичный формат решает эту проблему частично.
Появится необходимость частичной загрузки данных из файла, предварительные вычисления данных и их кеширование в файле, ... .

Таким образом, проблемы сериализации больших объемов данных, возникающие у прикладных программистов, свойственны файловым системам.
Эти проблемы в файловых системах уже решены.
Поэтому мы в нашем предмете изучим внутреннее строение файловых систем.

% Пример формата файла *.doc
Офисный текстовый документ состоит из набора внедренных файлов: текстов, стилей, рисунков, таблиц.
Внутреннее устройство формата файла `doc` от Microsoft Office выглядит как файловая система поверх файла.
Современный формат `docx`, основанный на стандарте "Office Open XML", состоит из наборов файлов и каталогов, заархивированных в формате `zip`.
-->
</div>
<div class="section" id="id13">
<h2>Использованные источники<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/1976007/what-characters-are-forbidden-in-windows-and-linux-directory-names">What characters are forbidden in Windows and Linux directory names?</a></p></li>
<li><p><a class="reference external" href="https://habr.com/ru/post/469667/">Права в Linux (chown, chmod, SUID, GUID, sticky bit, ACL, umask)</a></p></li>
<li><p><a class="reference external" href="http://www.interface.ru/home.asp?artId=18352">Анатомия журналируемых файловых систем Linux</a></p></li>
</ol>
</div>
<div class="section" id="id14">
<h2>Вопросы для самоконтроля<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Вычислите размер неиспользуемой части последнего кластера файла.</p></li>
<li><p>Зачем в служебной области FAT понадобилось хранить номер последнего выделенного кластера?</p></li>
</ol>
<!--
Особенность UNIX-систем: во все, что можно записать/считать данные представлены в виде файла.
-->
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lesson"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="development-tools.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Инструментальные средства</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="process-management.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Процессы</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Лазарев В.В.<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>
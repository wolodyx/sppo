
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Процессы &#8212; Системное и прикладное ПО</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Межпроцессное взаимодействие" href="ipc.html" />
    <link rel="prev" title="Файловая система" href="file-system.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Системное и прикладное ПО</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Введение в учебный предмет
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Введение
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="computer-in-life.html">
   Компьютер в жизни человека
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="binary-code.html">
   Двоичный код
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computer-hardware.html">
   Типы компьютеров
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computer-software.html">
   Программное обеспечение
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Операционная система
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="operating-system.html">
   Операционная система
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="development-tools.html">
   Инструментальные средства
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="file-system.html">
   Файловая система
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Процессы
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Связь с программами
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ipc.html">
   Межпроцессное взаимодействие
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="text-based-user-interface.html">
   Текстовый интерфейс
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="command-line-format.html">
     Формат команд командной строки
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="graphical-user-interface.html">
   Графический интерфейс
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Разработка программ
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="software-license.html">
   Лицензирование
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="programming-languages.html">
   Языки программирования
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-development.html">
   Проект программы
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-configuration.html">
   Конфигурирование
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-distribution.html">
   Распространение
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="software-installation.html">
   Установка
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Практические занятия
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/create-virtual-machine.html">
   Создание виртуальной машины
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/view-edit-text.html">
   Просмотр и редактирование текста
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/file-system.html">
   Работа с файловой системой
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/help-system.html">
   Справочная система man
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/environment-variables.html">
   Работа с переменными среды
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../labour/command-line-parse.html">
   Разбор аргументов программы
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/lesson/process-management.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   Как исполняется программа
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   Гарвардская архитектура
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   Принстонская архитектура
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   Инициализация системы
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   Дисбаланс производительности
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   Типы процессов
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   Многозадачность
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   Модель процессов
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id10">
   Планирование выполнения процессов
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id11">
   Иерархия процессов
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ps">
   ⛏ Утилита ps
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   Жизненный цикл
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id13">
     Создание процесса
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id14">
     Завершение процесса
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id15">
   Сигналы
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#top">
   ⛏ Утилита top
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id16">
   Управление заданиями
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id17">
   Потоки
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id18">
   Облегченные потоки
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id19">
   Асинхронный ввод-вывод
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id20">
   Заключение
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id21">
   Использованные источники
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="id1">
<h1>Процессы<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Процесс, наряду с файлом и адресным пространством, является ключевым понятием операционной системы.</p>
<p>Если программа – это кулинарная книга с рецептами, то процесс – это действие по приготовлению блюда.</p>
<div class="section" id="id2">
<h2>Как исполняется программа<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Компьютер начинает функционировать после подачи на него электропитания.</p>
<p>Процессор, центральный элемент компьютера, сразу же после включения находится в неопределенном состоянии.
Переходные процессы во внутренних цепях, вызванные появлением напряжения, привносят в регистры случайные значения.
Процессор приводится в начальное состояние подачей активного сигнала на контакт RESET.
После этого в регистры процессора записываются заложенные значения.</p>
<p>Как только сигнал RESET убирается, процессор начинает исполнять инструкции.
Регистр процессора, называемый <strong>счетчиком команд</strong>, содержит адрес следующей исполняемой инструкции в памяти.
После сброса процессора в счетчик команд заносится некоторое задокументированное значение.
По этому адресу в памяти должна располагаться программа.
Инструкция загружается из памяти и исполняется.
Счетчик увеличивается или на единицу или изменяется инструкцией, например для выполнения переходов.
Память, в которой располагается программа, называется <strong>сегментом кода</strong>.</p>
<p>Данные располагаются в оперативной памяти, куда у процессора есть прямой доступ.
Процессор с помощью инструкций загружает данные из памяти, преобразует их и отправляет обратно в память.
Память, содержащая данные, называется  <strong>сегментом данных</strong>.</p>
<p>Существует особый данные, располагаемые в оперативной памяти – это <strong>стек</strong>.
В отличие от предыдущих данных с чтением и записью в произвольные места, в стек данные помещаются только на вершину и берутся только из вершины.
Стек используется для организации подпрограмм – наборов инструкций для многократного использования.
Подпрограммы уменьшают общий размер программы за счет повторного использования одни и тех же инструкций.
Данные для подпрограмм передаются через стек.
В стек кладут текущее значение счетчика команд и аргументы подпрограммы.
Далее в счетчик команд заносят адрес подпрограммы и выполенение переходит на нее.
Подпрограмма обращается к стеку за исходными данными.
При завершении указатель на стек уменьшается на размер аргументов и из стека берется адрес для возврата в вызывающую функцию.
Счетчик команд модифицируется этим адресом и происходит возврат в вызывающую функцию.
Подпрограмма в свою очередь может вызвать другу подпрограмму и так далее.
Заложенные в стек данные для вызова одной подпрограммы называются <strong>фреймом</strong>.
Память под стек называется <strong>сегментом стека</strong>.</p>
<div class="figure align-default">
<img alt="../_images/stack.webp" src="../_images/stack.webp" />
</div>
<p>Процессор представляет собой сложный конечный автомат.
Его состояние хранится в регистрах.
По ходу выполнения программы содержимое регистров меняется.
Данные программы хранятся не только в сегментах данных и стека, но и в регистрах.</p>
<p>Состояние исполняемой программы задается следующими данными:</p>
<ul class="simple">
<li><p>сегментом кода;</p></li>
<li><p>сегментом данных;</p></li>
<li><p>сегментом стека;</p></li>
<li><p>регистрами процессора;</p></li>
<li><p>счетчиком команд.</p></li>
</ul>
</div>
<div class="section" id="id3">
<h2>Гарвардская архитектура<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>На рисунке ниже показана упрощенная функциональная схема компьютера из процессора (CPU), памяти данных (RAM) и программ (ROM).
Микросхема ROM (<strong>R</strong>ead <strong>O</strong>nly <strong>M</strong>emory) хранит программу, а RAM (<strong>R</strong>andom <strong>A</strong>ccess <strong>M</strong>emory) – данные.
Общего у них то, что они позволяют обращаться к любой ячейке памяти по адресу, устанавливаемой на шине <code class="docutils literal notranslate"><span class="pre">addr</span></code>.
Значение ячейки данных появляется на шине данных <code class="docutils literal notranslate"><span class="pre">data</span></code>.
К шине адреса и данных подключены сразу два потребителя: ROM и RAM.
Так как невозможно считать одновременно два значения из одной шины данных, то используют управляющий сигнал от процессора.
При одном значении активируется ROM, при втором значении – RAM.</p>
<p>Память ROM в отличие от RAM (Random Access Memory) не позволяет записывать значения, используя процессор.
Программа записывается в ROM с помощью специального устройства – <strong>программатора</strong>.
Запись программы в микросхему называют <strong>прошиванием</strong>, а программу по другому еще называют <strong>прошивкой</strong>.</p>
<p>Но особенность ROM в том, что данные в ней не теряются после отключения питания, что не скажешь про оперативную память RAM.</p>
<div class="figure align-default">
<img alt="../_images/cpu-rom-ram.png" src="../_images/cpu-rom-ram.png" />
</div>
<p>Архитектура компьютера, в которой программа и данные размещены отдельно, называется <strong>гарвардской</strong>.
Исторически она появилась первой.
Функциональный блок ROM был представлен перфокартой, магнитной лентой или панелью управления с перемычками (тумблерами).
После включения питания, программа всегда находится в памяти.
И такая программа не может быть изменена в процессе работы компьютера.</p>
<p>Гарвардская архитектура используется в <strong>специализированных компьютерах</strong>, то есть в компьютерах, решающих одну задачу.
Отличительная черта таких компьютерах состоит в том, что на процессоре исполняется только одна программа.
Она монопольно владеет всеми ресурсами компьютера.</p>
<p>Примерами такого компьютера являются управляющие устройства бытовой техники (холодильника, микроволновой печи), бортовые компьютеры автомобилей, самолетов, спутников, ракет.</p>
<p>Функциональная схема выше с CPU, ROM и RAM объединяется в одной микросхеме, называемой <strong>микроконтроллером</strong>.
Кроме них, внутри содержатся разные внешние устройства: таймер, преобразователи аналогового сигнала в цифровой (АЦП) и обратно (ЦАП), последовательный порт, поддержка USB и многое другое.
Это своего рода компьютер на одной микросхеме.
Если программа не помещается во внутреннюю память микроконтроллера, то вместо подключения внешней памяти, приобретают микроконтроллер с большей внутренней памятью.</p>
<div class="figure align-default">
<img alt="../_images/ATmega328PB.jpg" src="../_images/ATmega328PB.jpg" />
</div>
</div>
<div class="section" id="id4">
<h2>Принстонская архитектура<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p><strong>Универсальный компьютер</strong>, в отличие от специализированного, решает разные задачи, в зависимости от загруженной программы.
Это возможно сделать только тогда, когда память программ доступна на запись.
Это получается совмещением памяти данных и программ.
Исполняемая программа размещается в оперативной памяти.
Такая архитектура компьютера называется <strong>принстонской</strong>, но больше она известна как <strong>архитектура фон Неймана</strong>.</p>
<p>Совмещение в памяти программ и данных позволяет создавать такую компьютерную систему, в которой можно создавать новые программы и запускать их.
Такое совмещение позволяет создавать программы и выполнять их оставаясь в рамках одной компьютерной системы.</p>
<p>Возникает очевидный вопрос: как в оперативной памяти появляется первая программа?
Ее необходимо скопировать, но в системе нет программы, которая бы скопировала программу.
Копированием пользовательских программ и их запуском занимается операционная система или ее часть – <strong>загрузчик</strong>.
Но кто загружает операционную систему?
Как называется тот микроб, который привнесет жизнь в систему с принстонской архитектурой?</p>
</div>
<div class="section" id="id5">
<h2>Инициализация системы<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>В IBM-PC совместимых компьютерах загрузка операционной системы начинается с BIOS.
После включения x86-совместимый процессор начинает выборку инструкций, начиная с адреса 0xFFFFFFF0.
Память с этого адреса отображается на микросхему ROM с системной программой BIOS (<strong>B</strong>asic <strong>I</strong>nput/<strong>O</strong>utput <strong>S</strong>ystem).</p>
<div class="figure align-default">
<img alt="../_images/bios-on-motherboard.jpg" src="../_images/bios-on-motherboard.jpg" />
</div>
<p>В задачу BIOS входит инициализация подключенных к процессору устройств и проверка их работоспособности и передача управления следующему загрузчику.
Программа BIOS обращается к диску и считывает в память RAM первый сектор диска и передает ему управление.
Первый сектор диска содержит <strong>главную загрузочную запись</strong> (MBR, Master Boot Record) – микропрограмму и информацию о разделах диска.
В одном или нескольких разделах диска располагаются файлы операционной системы.
Микропрограмма MBR обращается к одному из разделов диска, на котором установлена операционная система.
Она загружает данные из <strong>загрузочного сектора раздела диска</strong> (VBR, Volume Boot Record).
Микропрограмма из VBR знает внутреннее устройство раздела диска и где располагается ядро операционной системы.
Она копирует его и передает ему управление.</p>
<p>Цепочка загрузчиков BIOS, MBR, VBR, ОС.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌──────┐  ┌─────┐  ┌─────┐  ┌────┐  ┌─────┐
│ BIOS ├─&gt;│ MBR ├─&gt;│ VBR ├─&gt;│ ОС ├─&gt;│ EXE │
└──────┘  └─────┘  └─────┘  └────┘  └─────┘
</pre></div>
</div>
<p>Универсальный компьютер не сможет функционировать без специальной программы, задача которой состоит в загрузке пользовательской программы в оперативную память.
Образ программы из внешнего устройства (диска) должна быть перенесена в оперативную память.
Функцию загрузчика пользовательских программ выполняет операционная система.</p>
<p>В компьютере с гарвардской архитектурой исполняется только одна программа, расположенная в отдельной памяти.
Запуск программы происходит по включению питания и сигналу сброса.
В принстонской архитектуре программа предварительно должна быть загружена из устройства накопителя данных в память.
Этим занимается специальная программа <strong>загрузчик</strong>.
Поэтому понятие программы двузначно – то, что лежит на диске и то, что запущено.
То, что в оперативной памяти, называется <strong>процессом</strong>.</p>
</div>
<div class="section" id="id6">
<h2>Дисбаланс производительности<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Программа выполняет вычисления по поступающим данным и отправляет результат обратно.
Условно, действия программы можно разделить на три части: ввод, вычисления и вывод.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌──────┐   ┌────────────┐   ┌───────┐
│      ├──&gt;┤            ├──&gt;┤       │
│ Ввод │   │ Вычисления │   │ Вывод │
│      ├&lt;──┤            ├&lt;──┤       │
└──────┘   └────────────┘   └───────┘
</pre></div>
</div>
<p>Интерактивные и графические программы большую часть своего времени находятся в ожидании действий пользователя: нажатия клавиш и перемещения мыши.
Программа реагирует на события и измененяет свое внутреннее состояние.
Изменение внутреннего состояния приводит к обновлению картины на экране.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────┐   ┌──────────────────┐   ┌─────────────────┐
│Событие│-&gt; │Реакция на событие│-&gt; │Обновление экрана│
└───────┘   └──────────────────┘   └─────────────────┘
</pre></div>
</div>
<p>Программы архивирования данных типа <code class="docutils literal notranslate"><span class="pre">tar</span></code> и <code class="docutils literal notranslate"><span class="pre">gzip</span></code> не относятся к интерактивным.
Они обращаются к диску за порцией новых данных, сжимают их и записывают результат на диск.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌─────────────────────────────────────────────────────────┐
│  ┌──────────────┐  ┌────────────────┐  ┌──────────────┐ │
│  │Чтение данных │  │Обработка данных│  │Запись порции │ │
└─&gt;┤из диска      ├-&gt;┤                ├-&gt;┤данных на диск├─┘
   └──────────────┘  └────────────────┘  └──────────────┘
</pre></div>
</div>
<p>Специальные программы для моделирования физических процессов, майнинг криптовалют, кодеки активно используют процессор и меньше обращаются к устройствам ввода и вывода.</p>
<p>Фоновые процессы, обслуживающие остальные процессы, неактивны пока к ним не обращаются.
При обращении к ним, они активируются для выполнения действия и затем снова отключаются.</p>
<p>По нагрузке на процессор и устройства ввода-вывода, процессы делятся на два типа:</p>
<ul class="simple">
<li><p>ограниченные скоростью вычислений;</p></li>
<li><p>ограниченные скоростью работы устройств ввода-вывода.</p></li>
</ul>
<p>Современный процессор на фоне остальных устройств обладает высокой производительностью.
Тактовая частота в 1 ГГц дает длительность одного такта в 1 нс или <span class="math notranslate nohighlight">\(10^{-9}\)</span> секунды.
Инструкции процессора исполняются за 1-2 такта и до нескольких сотен тактов.
Длительность зависит от сложности инструкции, расположения операндов.
Если предположить в среднем 10 тактов на инструкцию, то при частоте 1 ГГц за одну секунду исполнится 100 миллионов инструкций.</p>
<p>Процесс не может постоянно использовать процессор.
Для продолжения вычислений ему нужны данные от пользователя и других процессов.
Эти данные запрашиваются у внешних устройств ввода – клавиатуры, диска, сетевой карты.
Скорость получения данных от внешних устройств значительно мала, по сравнению со скоростью процессора.</p>
<p>Рассмотрим терминал и подключенную к нему клавиатуру.
Даже если пользователь печатает со скоростью пулеметной очереди (600 знаков в минуту), ожидание в 100 мс между нажатиями клавиш по меркам процессора много и достаточно на исполнение 10 миллионов инструкций.</p>
<p>Устройства HDD для считывания и записи используют движущиеся части – вращающийся диск и перемещающуюся считывающую головку.
На позиционирование головки тратится время около 10 мс.
За это время процессор может выполнить 1 миллион инструкций.</p>
<p>Скорость передачи данных через компьютерную сеть зависит от количества маршрутизаторов, через которые проходит путь пакетов, степени загрузки сетевого оборудования, качества инфраструктуры.
В локальных сетях, из-за их малых рамеров, издержки на передачу данных не велики и составляют около сотен микросекунд.
Но ситуация хуже для глобальной сети.
В них задержки составляют от 100 мс до нескольких секунд.</p>
</div>
<div class="section" id="id7">
<h2>Типы процессов<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Существуют три типа процессов:</p>
<ul class="simple">
<li><p>системные;</p></li>
<li><p>демоны;</p></li>
<li><p>прикладные.</p></li>
</ul>
<p>Системный процесс – это часть ядра операционной системы.
Он обладает широкими привилегиями.
По сравнению с остальными процессами, он не запусается из исполняемого файла.</p>
<p>Термин “демон” пришел из операционных систем типа UNIX.
Для Windows синонимом к нему являются службы.</p>
<p>Демон не принимает данные от клавиатуры и не выводит их на экран, то есть он не привязан к терминалу и пользователю.
Вместо этого демон связывается с другими программами и предоставляет им услуги.
Демоны обслуживают программы пользователей.</p>
<p>Прикладные процессы запускаются пользователем и привязаны к его терминалу.
Если пользователь выходит из системы, то его процессы завершаются.</p>
</div>
<div class="section" id="id8">
<h2>Многозадачность<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>В современном компьютере параллельно выполняются несколько программ.
Пользователь может одновременно слушать музыку, просматривать веб-страницы через браузер, держать запущенным почтовый клиент и мессенджер.
В фоновом режиме работают службы, предоставляющие услуги остальным программам.
Системные процессы операционной системы управляют ресурсами компьютера.</p>
<p>Один процессор может обслужить все программы за счет быстрого переключения между ними.
В итоге создается ощущение, что все процессы работают.
Такой способ организации выполнения команд называется <strong>мультипрограммированием</strong>.</p>
<p>Более полное использование ресурсов компьютера.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌─────────────────────────────────────────┐
│             Physical memory             |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Process| │Process| │Process| ... │Process|
└───────┘ └───────┘ └───────┘     └───────┘
┌─────────────────────────────────────────┐
│               Physical CPU              |
└─────────────────────────────────────────┘
</pre></div>
</div>
<p>Из-за разного поведения программ и высокой производительности процессора появилась возможность мультипрограммирования за счет многозадачности.
Многозадачность поддерживается всеми современными операционными системами.
Так как UNIX изначально ориентировалась как многопользовательская система, то она поддерживает многозадачность с момента своего появления, с 1970 года.</p>
</div>
<div class="section" id="id9">
<h2>Модель процессов<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│memory | │memory | │memory |     │memory |
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Process| │Process| │Process| ... │Process|
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│  CPU  | │  CPU  | │  CPU  |     │  CPU  |
└───────┘ └───────┘ └───────┘     └───────┘
</pre></div>
</div>
<p>Образ процесса</p>
<p>Исполнением программы занимается центральный процессор.
Процессор последовательно исполняет инструкции программы и формирует в регистрах и памяти результат.
То, какая инструкция должна быть выполнена следующей, показывает регистр процессора, называемый <strong>счетчик адреса команд</strong>.</p>
<p>Вызов программной процедуры состоит из подготовки аргументов, сохранению текущего счетчика команд и загрузки нового значения счетчика, указывающего на местоположение процедуры.
Текущий счетчик команд и аргументы для передачи в процедуру сохраняются в стековой памяти.
Расположение вершины стека задается через регистр процессора <strong>указатель на стек</strong>.</p>
<p>Для исполнения программы необходимы ресурсы: оперативная память для данных и стека, файлы, процессор с его регистрами.
Программа, данные и ресурсы составляют вместе процесс.</p>
<p>Программа может быть запущена несколько раз и каждому запуску будет соответствовать отдельный процесс.
Каждый процесс, хотя и обладает одними и теми же инструкциями, но будут иметь разные состояния (ресурсы и данные).</p>
</div>
<div class="section" id="id10">
<h2>Планирование выполнения процессов<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>Какому процессу и на какое время отдать процессор решает <strong>планировщик</strong> (диспетчер задач) – часть операционной системы.
От качества его работы зависит общая эффективность использования процессора и удовлетворенность пользователя.</p>
<p>То, как планировщик распределяет процессор между процессами называется <strong>алгоритмом планирования</strong>.</p>
<p>Самый простой способ планирования – отдавать процессор активному процессу.</p>
<p>Процесс может решить сам, когда ему отдавать процессор.
Преимущество. Не нужно защищать разделяемые структуры данных. Проще писать программы.</p>
<p>процесс снимается с процессора по истечению кванта времени или блокированию.</p>
<p>Блокированный процесс не может воспользоваться процессором, так как ожидает данные.</p>
<p>Выделяют три состояния, в которых может находиться процесс:</p>
<ul class="simple">
<li><p>выполняемый;</p></li>
<li><p>готовый;</p></li>
<li><p>заблокированный.</p></li>
</ul>
<p>Простейшая диаграмма сотояния процесса показана ниже</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>┌──────────────┐   ┌───────────┐
│🏃 выполнение ├&lt;─&gt;┤ 🧍готовый │
└──────────┬───┘   └──┬────────┘
           ↓          ↑
        ┌──┴──────────┴────┐
        │ 🧘 блокированный │
        └──────────────────┘
</pre></div>
</div>
<p>Выполняемый процесс переходит в блокированное состояние после запроса отсутствюущих данных.
Для получения данных запрос перенаправляется устройству ввода.</p>
</div>
<div class="section" id="id11">
<h2>Иерархия процессов<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="ps">
<h2>⛏ Утилита ps<a class="headerlink" href="#ps" title="Permalink to this headline">¶</a></h2>
<p>Утилита <code class="docutils literal notranslate"><span class="pre">ps</span></code> (<strong>p</strong>rocess <strong>s</strong>tatus) выводит отчет о состоянии процессов в системе.
По умолчанию утилита выводит краткую информацию о процессах пользователя, запущенных из терминала.
Одним из процессов будет сам <code class="docutils literal notranslate"><span class="pre">ps</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>skt@home:~$ ps
    PID TTY          TIME CMD
  <span class="m">34326</span> pts/0    <span class="m">00</span>:00:00 bash
  <span class="m">84494</span> pts/0    <span class="m">00</span>:00:00 ps
</pre></div>
</div>
<p>Первая строка содержит 4 заголовка, использующихся для описания процессов в последующих строках.
Вывод представляет таблицу из столбцов:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PID</span></code> – идентификатор процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TTY</span></code> – связанный с процессом терминал.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIME</span></code>– процессорное время, которое досталось процессу.</p></li>
<li><p>`CMD  – команда, использованная для запуска.</p></li>
</ul>
<p>Чтобы отобразить все процессы в системе используют опцию <code class="docutils literal notranslate"><span class="pre">-e</span></code> или ее синоним <code class="docutils literal notranslate"><span class="pre">-a</span></code>.
Таблица со всеми процессами вероятнее не хватит высоты экрана.
Удобнее перенаправить вывод <code class="docutils literal notranslate"><span class="pre">ps</span></code> для просмотра в <code class="docutils literal notranslate"><span class="pre">less</span></code> командой <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">-e</span> <span class="pre">|</span> <span class="pre">less</span></code> и уже там воспользоваться навигацией и поиском.</p>
<p>Чтобы узнать, сколько всего процессов в системе, включим нумерацию строк в <code class="docutils literal notranslate"><span class="pre">less</span></code> опцией <code class="docutils literal notranslate"><span class="pre">-N</span></code>.
Номер последней строки за вычетом первой строки покажет количество процессов.
Для подсчета символов, слов и строк существует утилита <code class="docutils literal notranslate"><span class="pre">wc</span></code>.
Она подсчитает только строки, если задать опцию <code class="docutils literal notranslate"><span class="pre">--line</span></code>: <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">-e</span> <span class="pre">|</span> <span class="pre">wc</span> <span class="pre">--line</span></code>.</p>
<p>Опция <code class="docutils literal notranslate"><span class="pre">-f</span></code> утилиты <code class="docutils literal notranslate"><span class="pre">ps</span></code> выведет дополнительные столбцы в отчете:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UID</span></code>   – идентификатор пользователя, запустившего процесс.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PPID</span></code>  – идентификатор родительского процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code>     – процент использования процессора.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">STIME</span></code> – время запуска процесса.</p></li>
</ul>
<p>Столбец <code class="docutils literal notranslate"><span class="pre">CMD</span></code> содержит не только имя программы, как в первом случае, но и список ее аргументов.
Список аргументов для некоторых процессов настолько велик, что строки разбиваются на несколько строк, чтобы вместиться в ширину экрана.
Это разрушает структуру таблицы.
Опция <code class="docutils literal notranslate"><span class="pre">-S</span></code> утилиты <code class="docutils literal notranslate"><span class="pre">less</span></code> запрещает перенос строк:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ps -e -f <span class="p">|</span> less -S
</pre></div>
</div>
<p>Значение <code class="docutils literal notranslate"><span class="pre">STIME</span></code> процесса <code class="docutils literal notranslate"><span class="pre">/sbin/init</span></code> покажет дату запуска операционной системы.</p>
<p>Иерархия процессов отображается опцией <code class="docutils literal notranslate"><span class="pre">-H</span></code>.
Дочерние процессы располагаются рядом сразу после родителя, а поле <code class="docutils literal notranslate"><span class="pre">CMD</span></code> отступает от родительского.
Опция <code class="docutils literal notranslate"><span class="pre">--forest</span></code> добавит в дерево ветки символами ASCII.
Утилита <code class="docutils literal notranslate"><span class="pre">pstree</span></code> нарисует дерево процессов более наглядно.</p>
<p>Опция <code class="docutils literal notranslate"><span class="pre">-l</span></code> утилиты <code class="docutils literal notranslate"><span class="pre">ps</span></code> выведет дополнительно следующие столбцы:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code>    – флаги процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code>    – состояние процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PRI</span></code> – приоритет процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NI</span></code>  – уступчивость процесса (nice).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SZ</span></code>  – размер процесса в физических страницах.</p></li>
</ul>
<p>Поле <code class="docutils literal notranslate"><span class="pre">ADDR</span></code> и <code class="docutils literal notranslate"><span class="pre">WCHAN</span></code> интереса нам не представляют.</p>
<p>Состояние процесса:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">D</span></code> – ожидание ввода-вывода и не может быть прерван.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span></code> – выполняется или в ожидании выполнения.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> – процесс в ожидании прерывания.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> – процесс остановлен (для отладки или сигналом Ctrl-Z).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Z</span></code> – “зомби”-процесс.</p></li>
</ul>
</div>
<div class="section" id="id12">
<h2>Жизненный цикл<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>Создание процесса<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>Новый процесс может создать только другой процесс.</p>
<p>Самый первый процесс с ядром операционной системы появляется на компьютере благодаря загрузчику.
При включении компьютера управление передается BIOS – небольшой программе, зашитой в микросхеме материнской платы.
BIOS из загрузочной части диска считывает программу-загрузчик, которая и загрузит операционную систему в оперативную память и передаст ей управление.</p>
<p>В системах UNIX ядро операционной системы запускает специальный процесс <code class="docutils literal notranslate"><span class="pre">init</span></code> из файла <code class="docutils literal notranslate"><span class="pre">/sbin/init</span></code> который будет являться родителем всех остальных процессов.</p>
<p>Запуск программ состоит из двух системных вызовов:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fork</span></code>, создание нового процесса;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">execve</span></code>, запуск программы внутри процесса.</p></li>
</ul>
<p>Создание процесса происходит через системный вызов операционной системы.
Системный вызов может выполнить только другой процесс.
Таким образом, новый процесс создается другим процессом.</p>
<p>Системный вызов <code class="docutils literal notranslate"><span class="pre">fork</span></code> раздваивает процесс на две части – родительский и дочерний.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Parent pid = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">getpid</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;fork error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is child with pid = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">getpid</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is parent %d, fork child %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">getpid</span><span class="p">(),</span><span class="w"> </span><span class="n">status</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Процессу перед запуском передают два типа значений:</p>
<ul class="simple">
<li><p>аргументы программы;</p></li>
<li><p>переменные окружения.</p></li>
</ul>
<p>Они доступны программе из главной функции <code class="docutils literal notranslate"><span class="pre">main</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">environ</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Набор строк типа “переменная=значение”.
Все строки образуют окружение процесса.</p>
<ul class="simple">
<li><p>домашний каталог (<code class="docutils literal notranslate"><span class="pre">HOME</span></code>);</p></li>
<li></li>
</ul>
</div>
<div class="section" id="id14">
<h3>Завершение процесса<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>После завершения с процессом ассоциируется целое число, называемое <strong>кодом завершения</strong>.
Код завершения знаком нам как значение, возвращаемое главной функцией <code class="docutils literal notranslate"><span class="pre">main</span></code> в языках программирования Си и C++.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Некоторый код.</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//&lt; Код завершения</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Его значение представлено типом int – знаковым целым числом.
Но операционная система использует только его младшие 8 бит.
Поэтому из программы получится возвратить только целые числа в диапазоне [0, 255].
Это демонстрирует следующий код:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Программа возвращает число, переданное первым аргументом.
В оболочке код возврата сохраняется в переменной <code class="docutils literal notranslate"><span class="pre">$?</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>skt@home:~$ gcc main.c -o program
skt@home:~$ ./program <span class="m">256</span>
skt@home:~$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">0</span>
</pre></div>
</div>
<p>Общепринято, что успешно завершенная программа возвращает число 0.
А все остальные значения интерпретируются как ошибка.
Кодами 126 и 127 командная оболочка сообщает, что программа не найдена или не является исполняемой.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>skt@home:~$ ./main.c
bash: ./main.c: Отказано в доступе
skt@home:~$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">126</span>
skt@home:~$ lsxxx
lsxxx: команда не найдена
skt@home:~$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">127</span>
</pre></div>
</div>
<p>Коды возврата выше 128 устанавливает операционная система по завершению процесса сигналом.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>skt@home:~$ yes &gt; /dev/null
^C
skt@home:~$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">130</span>
</pre></div>
</div>
<p>Получается, что программа для обозначения ошибок может использовать коды только в диапазоне от 1 до 127.</p>
<p>Обычный способ завершить программу для программиста – это выйти из функции <code class="docutils literal notranslate"><span class="pre">main</span></code> командой <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">&lt;number&gt;</span></code>.
Кодом завершения процесса станет целое число <code class="docutils literal notranslate"><span class="pre">&lt;number&gt;</span></code>.
Но существует второй способ, удобный тем, что он позволяет завершить выполнение из любой процедуры.
Это функция <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">exit(int)</span></code> стандартной библиотеки Си.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">func</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>skt@home:~$ gcc main.c -o program
skt@home:~$ ./program
skt@home:~$ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">1</span>
</pre></div>
</div>
<p>Оба способа выхода из программы (завершения процесса) через <code class="docutils literal notranslate"><span class="pre">return</span></code> и <code class="docutils literal notranslate"><span class="pre">exit</span></code> удобны тем, что уведомляют остальные части программы о скором завершении.
Это означает, что файловые буферы сбросятся на диск и выполнятся пользовательские функции, зарегистрированные через <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">atexit(void(*func)(void))</span></code>.</p>
<p>Третий способ выхода из программы через системный вызов <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">_exit(int)</span></code> завершает программу сразу, не предоставляя ему времени на подготовку.
Код ниже демонстрирует это.
Строка <code class="docutils literal notranslate"><span class="pre">hello</span></code> не сбросится на диск.
Но если убрать вызов функции <code class="docutils literal notranslate"><span class="pre">_exit(1)</span></code>, то файл был бы не пуст.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;x.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;w&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">fwrite</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Выше мы рассмотрели способы завершения процесса по его собственному желанию.
Процесс могут также завершить операционная система и другой процесс.</p>
<p>Причина, по которой операционная система решает завершить процесс, связана с недопустимым поведением процесса.
Это обращение по недоступному адресу, попытка выполнить запрещенную инструкцию, деление на ноль.
Такие действия прерывают процессор, который сообщает об этом операционной системе.
Та в свою очередь уничтожает хулигана.</p>
<p>Прерывание процесса операционной системой выполняется отправкой сигнала.
Сигнал может отправить и другой процесс через системный вызов <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kill(pid_t,</span> <span class="pre">int)</span></code>.</p>
<p>Код завершения процесса предназначается для его родителя.
Родитель получает его посредством системного вызова <code class="docutils literal notranslate"><span class="pre">wait</span></code> (<code class="docutils literal notranslate"><span class="pre">waitpid</span></code>, <code class="docutils literal notranslate"><span class="pre">waitid</span></code>).
Функция блокирует родителя до тех пор, пока дочерний процесс не завершится.
Один из параметров функции проинициализируется кодом завершения.</p>
<p>О родительского процесса может быть много дочерних процессов.
Возникает вопрос: если родитель пропустит момент завершения дочерних процессов, то как он узнает о результатах их исполнения?
Дочерние процессы после завершения не удаляются из системы.
Они отмечаются особым статусом “зомби”.
Зомби-процесс больше не рассматривается планировщиком.
Он просто ждет родителя, когда он опросит о его коде завершения.
После этого процесс исчезает из системы.</p>
<!--
Модель процессов
Модель потоков
Создание процесса
Завершение процесса
Состояния процесса
Контекст процесса
Планирование
Сигналы
Управление заданиями
Утилита top
Асинхронное программирование
-->
</div>
</div>
<div class="section" id="id15">
<h2>Сигналы<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>Операционная система управляет состоянием процесса через сигналы.
Сигнал предоставляет собой именованное событие, требующее реагирования на него процесса.
В ответ на сигнал выполнение процесса останавливается и вызывается специальная процедура, называемая <strong>обработчиком сигнала</strong>.
В обработчике прописаны действия на событие.
То, как надо реагировать на событие, устанавливает операционная система.
Процесс может переопределить обработчик, установив свою подпрограмму.
Но на некоторые типы сигнала установить обработчик не получится.</p>
<p>Для отправки сигнала операционная система предоставляет системный вызов <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kill(pid_t,</span> <span class="pre">int)</span></code>.
Первый аргумент указывает идентификатор процесса, которому посылается сигнал.
Тип сигнала указывается вторым параметром, которое указывает на информируемое сигналом событие.
Системный вызов для отправки сигналов позволяет управлять состоянием процесса и другим процессам.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Название функции заставляет волноваться.
Системный вызов опасности для пользователя не представляет, потому что первый аргумент указывает на процесс, а не пользователя (<code class="docutils literal notranslate"><span class="pre">uid_t</span></code>).
Иначе это выглядело бы как уничтожение процессом неугодного пользователя.</p>
</div>
<p>Часто сигналы применяют для завершения неугодного или провинившегося процесса, что и дало имя системному вызову.
Сигнал под номером 2 (<code class="docutils literal notranslate"><span class="pre">SIGINT</span></code>) посылается терминалом активному процессу в ответ на нажатие пользователем <code class="docutils literal notranslate"><span class="pre">Ctrl+Z</span></code>.
Сигнал просит процесс завершиться.
Если программа не переопределила стандартный обработчик, то процесс завершится системным вызовом <code class="docutils literal notranslate"><span class="pre">exit</span></code>.
Альтернативный обработчик может корректно освободить ресурсы, вывести информацию о завершении.
Но может проигнорировать сигнал и процесс будет выполняться дальше.</p>
<p>Немедленное завершение процессов происходит сигналом под номером 9(<code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>).
Для него невозможно заменить стандартный обработчик.</p>
<p>Для отправки сигнала пользователь может использовать одноименную утилиту <code class="docutils literal notranslate"><span class="pre">kill</span></code> в формате</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">kill</span> <span class="m">805</span>
</pre></div>
</div>
<p>Сигналы к любому процессу может отправлять только суперпользователь.
Остальные пользователи ограничены процессами из своего круга.</p>
</div>
<div class="section" id="top">
<h2>⛏ Утилита top<a class="headerlink" href="#top" title="Permalink to this headline">¶</a></h2>
<p>Утилита <code class="docutils literal notranslate"><span class="pre">top</span></code> (<strong>t</strong>able <strong>o</strong>f <strong>p</strong>rocess) выводит обновляемый во времени отчет о состояниях процессов в системе.
Аналог диспетчера задач в Windows, но для UNIX в текстовом режиме.
Команды выхода из программы и вызова справки совпадают с <code class="docutils literal notranslate"><span class="pre">less</span></code> – это <code class="docutils literal notranslate"><span class="pre">q</span></code> и <code class="docutils literal notranslate"><span class="pre">h</span></code>.
В отличие от <code class="docutils literal notranslate"><span class="pre">ps</span></code>, <code class="docutils literal notranslate"><span class="pre">top</span></code> – интерактивная программа.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u&lt;имя</span> <span class="pre">пользователя&gt;</span></code> – фильтрация процессов по пользователю.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span> </code> (<code class="docutils literal notranslate"><span class="pre">u</span></code> и пробел) – вернуть обратно всех пользователей.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d&lt;интервал</span> <span class="pre">в</span> <span class="pre">секундах&gt;</span></code> – интервал обновления отчета.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> – выбор столбца для сортировки.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – выбор столбцов для показа.</p></li>
</ul>
<p>Столбцы таблицы:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PID</span></code> – идентификатор процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USER</span></code> – имя пользователя, запустившего процесс.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PR</span></code> – приоритет процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NI</span></code> – уступчивость процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> – состояние процесса.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%CPU</span></code> – процент использованного процессорного времени.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIME+</span></code> – сотни процессорных секунд, использованных процессором.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">top</span></code> не поддерживает прокрутку экрана.
Содержимое за пределами экрана не просмотришь.
Это можно понять, если представить, что основная цель – это посмотреть процессы, отсортированные по критериям.
Утилита <code class="docutils literal notranslate"><span class="pre">htop</span></code> обходит этот недостаток <code class="docutils literal notranslate"><span class="pre">top</span></code>.</p>
</div>
<div class="section" id="id16">
<h2>Управление заданиями<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id17">
<h2>Потоки<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>Потоки имеют общее адресное пространство, ресурсы ОС.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌─────────────────────────────────────────┐
│            Virtual memory               |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Thread | │Thread | │Thread | ... │Thread |
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│  CPU  | │  CPU  | │  CPU  |     │  CPU  |
└───────┘ └───────┘ └───────┘     └───────┘
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h2>Облегченные потоки<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>Облегченные потоки (fiber).
Реализованы в пространстве пользователя.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>┌─────────────────────────────────────────┐
│              Virtual memory             |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│ Fiber | │ Fiber | │ Fiber | ... │ Fiber |
└───────┘ └───────┘ └───────┘     └───────┘
┌─────────────────────────────────────────┐
│               Virtual CPU               |
└─────────────────────────────────────────┘
</pre></div>
</div>
<p>Процесс за данными обращается к операционной системе, используя системный вызов.
Операционная система перенаправляет запрос к устройству ввода, а процесс остается в ожидании данных.
Состояние ожидания данных называется <strong>блокированием</strong>, а приведшая к этому функция называется <strong>блокирующей функцией</strong>.
Чтобы процессор зазря не простаивал, заблокированный процесс снимается с исполнения с процессора.
Процессор передается другому процессу.</p>
<p>Обратная операция, отправка данных на устройства вывода (запись в файл, отправка в сеть, вывод на экран), также медлительна.
Но в этом случае процесс не блокируется.
Данные сохраняются во внутренней памяти операционной системы.
Внутренняя память называется <strong>буфером</strong>, а накопление данных в буфере – <strong>буферизацией</strong>.
Когда данные накапливаются достаточно (или буфер заполняется), происходит отправка данных на устройство вывода.</p>
<p>Человек по ходу своей жизни переходит в блокированное состояние.
Например, ожидание услуги, стоя в очереди.
Долгие очереди постепенно изживают себя, заменяясь предварительной записью, оптимизацией очередей подстраиванием обслуживания под возрастающие нагрузки, передачи документов и сообщение по телефону о подготовленных результатах.</p>
<p>Аналогичный тренд наблюдается в программировании: блокирующие функции ввода-вывода заменяются <strong>неблокирующими синхронными и асинхронными функциями</strong>.
Альтернативой блокирующих функций является неблокирующие.
Неблокирующая функция проверяет готовность данных.
Если они готовы, то она возвращает результат, иначе вернет признак отсутствия.
Но программа не всегда может предугадать появление данных.
Каждый раз вызывать неблокирующую функцию неудобно.
В ответ на это используют неблокирующую асинхронную функцию.
Такая функция передает системе указатель на функцию, называемую также <strong>функцией обратного вызова</strong>.
Эта функция вызовестия системой, когда данные будут готовы.</p>
</div>
<div class="section" id="id19">
<h2>Асинхронный ввод-вывод<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id20">
<h2>Заключение<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>Знания о процессах и планировщике позволят создавать более эффективные программы.</p>
</div>
<div class="section" id="id21">
<h2>Использованные источники<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p><a class="reference external" href="https://lateblt.tripod.com/bit68.txt">What Happens When A CPU Starts</a></p></li>
<li><p><a class="reference external" href="https://tproger.ru/articles/asynchronous-programming/">Асинхронность в программировании</a></p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./lesson"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="file-system.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Файловая система</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="ipc.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Межпроцессное взаимодействие</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Лазарев В.В.<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>
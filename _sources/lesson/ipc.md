# Межпроцессное взаимодействие

Каждый процесс обладает своим адресным пространством. Процесс не может обратиться в чужое пространство. При обращении к участку памяти другого процесса, процессором генерируется исключительная ситуация segmentation violation. Это дает защиту от случайного или намеренного нарушения данных одного процесса другим. Таким образом, самостоятельно процессы не обладают средствами взаимодействия друг с другом. Такое средство предоставляет только ОС.

Разделение программы на взаимодействующие процессы необходимо по различным причинам. Во-первых, это упрощает разработку программы за счет использования уже существующих программ. Во-вторых, уменьшается сложность программного кода за счет декомпозиции. Так, для загрузки из сети файла используют curl, для редактирования документа — существующий текстовый редактор, ... . В-третьих, несколько процессов используются для увеличения производительности программы за счет разделения объема работы по нескольким физическим процессорам и распределенным компьютерам.

Существуют разные способы взаимодействия процессов друг с другом. Взаимодействующие процессы могут располагаться на одной машине или связанных по сети машинах. Передача данных может быть односторонней или двухсторонней. Процессы могут быть равноправными или состоять в подчинении. Способы отличаются по сложности реализации и вносимую в программу неопределенности. Но суть у всех одна — передать данные от одного процесса другому.

Каждый из способов имеет различную эффективность взаимодействия. Эта эффективность определяется двумя параметрами — пропускной способностью и задержкой. Пропускная способность показывает количество данных, которое может быть обработано за единицу времени. Задержка показывает время между отправкой данных и их получением.

В ОС UNIX межпроцессное взаимодействие развито лучше. В нее изначально закладывались идеи по разбиению сложной системы на взаимодействие небольших составляющих. Открытый код позволял экспериментировать и искать более эффективные способы взаимодействия компонент друг с другом.

Добавить про многопоточность.

## Обмен данными через файл

Самый простой способ взаимодействия процессов — это использование общего файла. Этот способ часто используется в одноразовых программах, сценариях командного интерпретатора, при использовании внешнего текстового редактора. Например, если команде git commit не задали текстового описания фиксируемых изменений, открывается внешняя программа (обычно vi) для ввода этого описания.

Файлы, используемые для обмена данными и хранения промежуточных результатов, называют временными. ОС предоставляет специальные возможности для работы с ними — получение уникального имени файла, организация их хранения в отдельном каталоге, их удаление при выходе из программы. Так, в UNIX для хранения временных файлов используется каталоги /tmp, ~/tmp. Содержимое каталога удаляется после каждой загрузки ОС. Для ОС Windows каталог с временными файлами располагаются в каталогах C\Windows\Temp и C\Users\user_name\AppData\Local.

Обмен данными через файл подвержен трем недостаткам. Во-первых, это замусоривание диска, когда обработка неожиданно обрывается, не дойдя до места удаления файла. Во-вторых, отсутствует координация процессов. Вследствие чего могут возникнуть коллизии — чтение данных в момент их записи. В-третьих, запись данных в файл — это долгая по времени операция.

## Каналы

Для взаимодействия с внешним миром программе доступны стандартные потоки ввода и вывода данных. Их предоставляет система в виде трех открытых файлов с номерами дескрипторов 0, 1 и 2. Поток под номером 0 настроен на ввод данных и по умолчанию ассоциирован с клавиатурой. Поток под номером 1 используется для вывода информационных, а номером 2 — для диагностических и отладочных данных. Они оба ассоциированы с монитором.

```{figure} ../_images/pipe.png
```

Для считывания и записи данных используются те же системные функции, что для работы с файлами. Но по сравнению с ними, потоки связаны с виртуальным файлом — системным буфером в памяти.

Данные со стандартных потоков могут ассоциироваться и с другими источниками, например с файлами. Если стандартный поток ввода связать с файлом, то программа считает данные из файла, вместо их ожидания от пользователя. Аналогично и вывод может быть подключен к файлу. Изменение потоков данных называется перенаправлением ввода-вывода. Перенаправление происходит на уровне ОС и не влияет на работу программы — она как и раньше считывает и записывает данные в стандартные потоки.

Стандартный поток вывода программы может быть перенаправлен в стандартный поток ввода другой программы. Такое соединение образует канал для односторонней передачи данных между программами.

Последовательное соединение двух и более программ для их совместной работы называется конвейером.

```{figure} ../_images/pipe-2.png
```

Конвейер из программ — это мощный инструмент пользователя UNIX. Он позволяют решать нестандартные задачи, используя для этого стандартные инструменты.

Недостатком каналов является их направленность в одну сторону. Невозможно передать потоки данных обратно.

## Сигналы

Сигналы используются для уведомления процесса о некотором произошедшем событии. Источником сигнала может быть ОС или другая программа. При получении сигнала процесс приостанавливает свое выполнение и выполняет специальную функцию — обработчик сигнала. В зависимости от типа сигнала, выполнение процесса может продолжиться или завершиться.

Сигналы можно игнорировать — не выполнять их обработку, или блокировать — отложить обработку. Некоторые сигналы не могут быть проигнорированы или обработаны пользовательской функцией. Тогда их обрабатывает ОС, а программа завершается.

Тип сигнала задается целым числом, которому соответствует символьное имя. Символьное имя начинается с префикса SIG.

| Тип сигнала | Описание |
|-------------|----------|
| SIGKILL | Немедленное завершение процесса. Сигнал не может быть обработан и проигнорирован. |
| SIGINT | Завершение процесса пользователем из командной оболочки сочетанием клавиш Ctrl+C. |
| SIGTERM | Просьба о завершении процесса. |
| SIGQUIT | Завершение процесса с выгрузкой памяти в файл. |
| SIGSTOP | Приостановка выполнения процесса. Не обрабатывается и не игнорируется. |
| SIGTSTP | Приостановка выполнения процесса пользователем из командной оболочки сочетанием клавиш Ctrl+Z. |
| SIGCONT | Возобновление приостановленного процесса. |
| SIGHUP | Потеря связи с терминалом пользователя. По умолчанию программа прерывается. В демонах используется для перечитывания файлов настроек. |
| SIGCHLD | Информация об изменении состояния дочернего процесса — завершен, приостановлен, возобновлен. |
| SIGSEGV | Ошибка обращения к виртуальной памяти. |
| SIGBUS | Ошибка обращения к физической памяти. |
| SIGFPE | Ошибка выполнения арифметической операции (переполнение, деление на ноль). |
| SIGUSR1, SIGUSR2 | Пользовательские сигналы. Могут интерпретироваться по-разному, в зависимости от процесса. |

У каждого сигнала, кроме SIGUSR1 и SIGUSR2, своя роль и изменять ее не рекомендуется. Эти сигналы используются для взаимодействия ОС и командной оболочки с программой пользователя. Программе от сигнала известны только тип и номер процесса-отправителя. Отправителю не важен результат обработки, поэтому функция-обработчик ничего не возвращает.

Для взаимодействия пользовательских программ между собой предназначены сигналы в интервале SIGRTMIN - SIGRTMAX, которые называются сигналами реального времени. В отличие от сигналов приведенных выше, они имеют следующие свойства:
* Приоритет доставки сигналов — если обработки ждут несколько сигналов, то сигнал с меньшим номером обработается раньше.
* Сигналы буферизируются — каждый посланный сигнал реального времени не потеряется и будет обработан.
* Вместе с сигналом можно передать дополнительную информацию.

Для отправки из командной оболочки сигналов процессам существует команда kill. Она в виде аргументов принимает тип сигнала и номер процесса.

Для работы с сигналами в стандартной библиотеке Си используются функции из заголовочного файла “signal.h”.

Демоны в UNIX (работающие в фоновом режиме программы) используют сигналы для взаимодействия с пользователем. Каждый запущенный демон формирует PID-файл с именем “daemon_name.pid” в каталоге “/run” или “/var/run”. Чтобы остановить демон, ему посылают сигнал TERM. На сигнал HUP демон повторно считывает настройки из файла.

Утилиту fetchmail используют для сбора почты из удаленных серверов. Запущенная один раз, она проверяет сервера на новую почту с некоторой задержкой, чтобы не нагружать сеть. Если пользователь запустит утилиту без аргументов еще раз, то она отправит сигнал первому процессу о внеочередной проверке серверов и завершится.

```{figure} ../_images/fetchmail-actions.png
```

## Сокеты

Сокеты — это название программного интерфейса, разработанного для обмена данными между процессами как на одном компьютере, таки и между связанными через сеть компьютерами. Был разработан в 1982 году для BSD UNIX. Является основным инструментом для создания клиент-серверных приложений и функционирования сети Интернет. Сокеты стандартизированы в POSIX и доступны во всех современных ОС с небольшими отличиями.

Для связи с процессом используется его адрес. Существуют два типа адресации процессов — INET-адрес и UNIX-адрес. INET-адрес для TCP/IP протокола состоит из IPv4 (IPv6) адреса и номера порта. Такие адреса позволяют связываться процессам через сеть. UNIX-адрес ограничивает взаимодействие процессов внутри компьютера. При этом не используются сетевые устройства, а обмен происходит через файл.

В зависимости от того, является ли программа клиентом или сервером, какое семейство протоколов для связи используется, будет различаться программный код в плане вызова функций.

При использовании протокола TCP/IP клиент и сервер устанавливают предварительную связь и договариваются о параметрах связи. Потерявшиеся или испорченные данные при передаче по сети будут отправлены повторно. Таким образом протокол гарантирует целостность принимаемых данных.

При использовании протокола UDP клиент и сервер не устанавливается предварительная связь. В этом случае нет гарантий, что переданные данные доходят до клиента. Но зато быстрее, чем TCP/IP.

## Отображение файла в память

Модификация данных в файле состоит из следующих операций. Перевести указатель на нужную позицию, прочитать данные в буфер, изменить данные в буфере и записать в файл данные из буфера. Каждое обращение к файлу приводит к системному вызову ядра, переключению контекста и работы с диском. Для более быстрой работы с файлом используют его отображение на память.

Намного эффективнее, чем использование файла. Потому что меньше обращений к памяти.

Для взаимодействия процессов, они могут отобразить один и тот же файл к себе на память.

## Разделяемая память

Способ обмена данными между процессами, при котором к одному участку памяти имеют доступ несколько процессов. Это наиболее эффективный способ передачи данных. Эффективный по времени, так как не используются системные вызовы ядра и соответственно нет переключения контекста. Эффективный по памяти, так как данные содержатся в единственном экземпляре. Способ может быть использован только для взаимодействия процессов на одной машине — не подойдет для сетевого взаимодействия. Так как разделяемая память общий ресурс, то для доступа к ней необходимо использовать семафор.

Каждый процесс имеет свое виртуальное адресное пространство, собранное из страниц физической памяти. Отображение виртуального адреса в физический выполняется с использованием таблицы отображения адресов. Разделяемый участок физической памяти встраивается в виртуальное адресное пространство процесса. Один и тот же участок разделяемой памяти для разных процессов будет иметь разные виртуальные адреса.

Управление разделяемой памятью стандартизировано POSIX. Оно состоит из функций shm_open, shm_unlink, ... .Более удобные средства предоставляются в библиотеках Boost (Boost.Interprocess) и Qt (QSharedMemory).

## Высокоуровневые способы взаимодействия процессов

Обмен сообщениями MPI.
Очереди сообщений (RabbitMQ, Apache ActiveMQ)
OpenMP

## Использованные источники

* [Как реализованы конвейеры в UNIX](https://habr.com/ru/company/mailru/blog/495484/)
* [Стандартные потоки ввода/вывода](http://xgu.ru/wiki/Стандартные_потоки_ввода/вывода)
* [Сигналы](http://citforum.ru/programming/unix/signals/)
* [Лекция. Средства межпроцессного взаимодействия. Сигналы](https://intuit.ru/studies/courses/47/47/lecture/1411?page=2)

# Процессы

Процесс, наряду с файлом и адресным пространством, является ключевым понятием операционной системы.

Если программа -- это кулинарная книга с рецептами, то процесс -- это действие по приготовлению блюда.

## Как исполняется программа

Компьютер начинает функционировать после подачи на него электропитания.

Процессор, центральный элемент компьютера, сразу же после включения находится в неопределенном состоянии.
Переходные процессы во внутренних цепях, вызванные появлением напряжения, привносят в регистры случайные значения.
Процессор приводится в начальное состояние подачей активного сигнала на контакт RESET.
После этого в регистры процессора записываются заложенные значения.

Как только сигнал RESET убирается, процессор начинает исполнять инструкции.
Регистр процессора, называемый **счетчиком команд**, содержит адрес следующей исполняемой инструкции в памяти.
После сброса процессора в счетчик команд заносится некоторое задокументированное значение.
По этому адресу в памяти должна располагаться программа.
Инструкция загружается из памяти и исполняется.
Счетчик увеличивается или на единицу или изменяется инструкцией, например для выполнения переходов.
Память, в которой располагается программа, называется **сегментом кода**.

Данные располагаются в оперативной памяти, куда у процессора есть прямой доступ.
Процессор с помощью инструкций загружает данные из памяти, преобразует их и отправляет обратно в память.
Память, содержащая данные, называется  **сегментом данных**.

Существует особый данные, располагаемые в оперативной памяти -- это **стек**.
В отличие от предыдущих данных с чтением и записью в произвольные места, в стек данные помещаются только на вершину и берутся только из вершины.
Стек используется для организации подпрограмм -- наборов инструкций для многократного использования.
Подпрограммы уменьшают общий размер программы за счет повторного использования одни и тех же инструкций.
Данные для подпрограмм передаются через стек.
В стек кладут текущее значение счетчика команд и аргументы подпрограммы.
Далее в счетчик команд заносят адрес подпрограммы и выполенение переходит на нее.
Подпрограмма обращается к стеку за исходными данными.
При завершении указатель на стек уменьшается на размер аргументов и из стека берется адрес для возврата в вызывающую функцию.
Счетчик команд модифицируется этим адресом и происходит возврат в вызывающую функцию.
Подпрограмма в свою очередь может вызвать другу подпрограмму и так далее.
Заложенные в стек данные для вызова одной подпрограммы называются **фреймом**.
Память под стек называется **сегментом стека**.

```{figure} ../_images/stack.webp
```

Процессор представляет собой сложный конечный автомат.
Его состояние хранится в регистрах.
По ходу выполнения программы содержимое регистров меняется.
Данные программы хранятся не только в сегментах данных и стека, но и в регистрах.

Состояние исполняемой программы задается следующими данными:
* сегментом кода;
* сегментом данных;
* сегментом стека;
* регистрами процессора;
* счетчиком команд.

## Гарвардская архитектура

На рисунке ниже показана упрощенная функциональная схема компьютера из процессора (CPU), памяти данных (RAM) и программ (ROM).
Микросхема ROM (**R**ead **O**nly **M**emory) хранит программу, а RAM (**R**andom **A**ccess **M**emory) -- данные.
Общего у них то, что они позволяют обращаться к любой ячейке памяти по адресу, устанавливаемой на шине `addr`.
Значение ячейки данных появляется на шине данных `data`.
К шине адреса и данных подключены сразу два потребителя: ROM и RAM.
Так как невозможно считать одновременно два значения из одной шины данных, то используют управляющий сигнал от процессора.
При одном значении активируется ROM, при втором значении -- RAM.

Память ROM в отличие от RAM (Random Access Memory) не позволяет записывать значения, используя процессор.
Программа записывается в ROM с помощью специального устройства -- **программатора**.
Запись программы в микросхему называют **прошиванием**, а программу по другому еще называют **прошивкой**.

Но особенность ROM в том, что данные в ней не теряются после отключения питания, что не скажешь про оперативную память RAM.

```{figure} ../_images/cpu-rom-ram.png
```

Архитектура компьютера, в которой программа и данные размещены отдельно, называется **гарвардской**.
Исторически она появилась первой.
Функциональный блок ROM был представлен перфокартой, магнитной лентой или панелью управления с перемычками (тумблерами).
После включения питания, программа всегда находится в памяти.
И такая программа не может быть изменена в процессе работы компьютера.

Гарвардская архитектура используется в **специализированных компьютерах**, то есть в компьютерах, решающих одну задачу.
Отличительная черта таких компьютерах состоит в том, что на процессоре исполняется только одна программа.
Она монопольно владеет всеми ресурсами компьютера.

Примерами такого компьютера являются управляющие устройства бытовой техники (холодильника, микроволновой печи), бортовые компьютеры автомобилей, самолетов, спутников, ракет.

Функциональная схема выше с CPU, ROM и RAM объединяется в одной микросхеме, называемой **микроконтроллером**.
Кроме них, внутри содержатся разные внешние устройства: таймер, преобразователи аналогового сигнала в цифровой (АЦП) и обратно (ЦАП), последовательный порт, поддержка USB и многое другое.
Это своего рода компьютер на одной микросхеме.
Если программа не помещается во внутреннюю память микроконтроллера, то вместо подключения внешней памяти, приобретают микроконтроллер с большей внутренней памятью.

```{figure} ../_images/ATmega328PB.jpg
```

## Принстонская архитектура

**Универсальный компьютер**, в отличие от специализированного, решает разные задачи, в зависимости от загруженной программы.
Это возможно сделать только тогда, когда память программ доступна на запись.
Это получается совмещением памяти данных и программ.
Исполняемая программа размещается в оперативной памяти.
Такая архитектура компьютера называется **принстонской**, но больше она известна как **архитектура фон Неймана**.

Совмещение в памяти программ и данных позволяет создавать такую компьютерную систему, в которой можно создавать новые программы и запускать их.
Такое совмещение позволяет создавать программы и выполнять их оставаясь в рамках одной компьютерной системы.

Возникает очевидный вопрос: как в оперативной памяти появляется первая программа?
Ее необходимо скопировать, но в системе нет программы, которая бы скопировала программу.
Копированием пользовательских программ и их запуском занимается операционная система или ее часть -- **загрузчик**.
Но кто загружает операционную систему?
Как называется тот микроб, который привнесет жизнь в систему с принстонской архитектурой?

## Инициализация системы

В IBM-PC совместимых компьютерах загрузка операционной системы начинается с BIOS.
После включения x86-совместимый процессор начинает выборку инструкций, начиная с адреса 0xFFFFFFF0.
Память с этого адреса отображается на микросхему ROM с системной программой BIOS (**B**asic **I**nput/**O**utput **S**ystem).

```{figure} ../_images/bios-on-motherboard.jpg
```

В задачу BIOS входит инициализация подключенных к процессору устройств и проверка их работоспособности и передача управления следующему загрузчику.
Программа BIOS обращается к диску и считывает в память RAM первый сектор диска и передает ему управление.
Первый сектор диска содержит **главную загрузочную запись** (MBR, Master Boot Record) -- микропрограмму и информацию о разделах диска.
В одном или нескольких разделах диска располагаются файлы операционной системы.
Микропрограмма MBR обращается к одному из разделов диска, на котором установлена операционная система.
Она загружает данные из **загрузочного сектора раздела диска** (VBR, Volume Boot Record).
Микропрограмма из VBR знает внутреннее устройство раздела диска и где располагается ядро операционной системы.
Она копирует его и передает ему управление.

Цепочка загрузчиков BIOS, MBR, VBR, ОС.

```
┌──────┐  ┌─────┐  ┌─────┐  ┌────┐  ┌─────┐
│ BIOS ├─>│ MBR ├─>│ VBR ├─>│ ОС ├─>│ EXE │
└──────┘  └─────┘  └─────┘  └────┘  └─────┘
```

Универсальный компьютер не сможет функционировать без специальной программы, задача которой состоит в загрузке пользовательской программы в оперативную память.
Образ программы из внешнего устройства (диска) должна быть перенесена в оперативную память.
Функцию загрузчика пользовательских программ выполняет операционная система.

В компьютере с гарвардской архитектурой исполняется только одна программа, расположенная в отдельной памяти.
Запуск программы происходит по включению питания и сигналу сброса.
В принстонской архитектуре программа предварительно должна быть загружена из устройства накопителя данных в память.
Этим занимается специальная программа **загрузчик**.
Поэтому понятие программы двузначно -- то, что лежит на диске и то, что запущено.
То, что в оперативной памяти, называется **процессом**.

## Дисбаланс производительности

Программа выполняет вычисления по поступающим данным и отправляет результат обратно.
Условно, действия программы можно разделить на три части: ввод, вычисления и вывод.

```
┌──────┐   ┌────────────┐   ┌───────┐
│      ├──>┤            ├──>┤       │
│ Ввод │   │ Вычисления │   │ Вывод │
│      ├<──┤            ├<──┤       │
└──────┘   └────────────┘   └───────┘
```

% Поведение интерактивных программ
Интерактивные и графические программы большую часть своего времени находятся в ожидании действий пользователя: нажатия клавиш и перемещения мыши.
Программа реагирует на события и измененяет свое внутреннее состояние.
Изменение внутреннего состояния приводит к обновлению картины на экране.

```
┌───────┐   ┌──────────────────┐   ┌─────────────────┐
│Событие│-> │Реакция на событие│-> │Обновление экрана│
└───────┘   └──────────────────┘   └─────────────────┘
```

Программы архивирования данных типа `tar` и `gzip` не относятся к интерактивным.
Они обращаются к диску за порцией новых данных, сжимают их и записывают результат на диск.

```
┌─────────────────────────────────────────────────────────┐
│  ┌──────────────┐  ┌────────────────┐  ┌──────────────┐ │
│  │Чтение данных │  │Обработка данных│  │Запись порции │ │
└─>┤из диска      ├->┤                ├->┤данных на диск├─┘
   └──────────────┘  └────────────────┘  └──────────────┘
```

Специальные программы для моделирования физических процессов, майнинг криптовалют, кодеки активно используют процессор и меньше обращаются к устройствам ввода и вывода.

Фоновые процессы, обслуживающие остальные процессы, неактивны пока к ним не обращаются.
При обращении к ним, они активируются для выполнения действия и затем снова отключаются.

По нагрузке на процессор и устройства ввода-вывода, процессы делятся на два типа:
* ограниченные скоростью вычислений;
* ограниченные скоростью работы устройств ввода-вывода.

% Производительность современного процессора
Современный процессор на фоне остальных устройств обладает высокой производительностью.
Тактовая частота в 1 ГГц дает длительность одного такта в 1 нс или $10^{-9}$ секунды.
Инструкции процессора исполняются за 1-2 такта и до нескольких сотен тактов.
Длительность зависит от сложности инструкции, расположения операндов.
Если предположить в среднем 10 тактов на инструкцию, то при частоте 1 ГГц за одну секунду исполнится 100 миллионов инструкций.

% Прерывание процесса на операции ввода-вывода
Процесс не может постоянно использовать процессор.
Для продолжения вычислений ему нужны данные от пользователя и других процессов.
Эти данные запрашиваются у внешних устройств ввода -- клавиатуры, диска, сетевой карты.
Скорость получения данных от внешних устройств значительно мала, по сравнению со скоростью процессора.

% Длительность между нажатиями клавиш
Рассмотрим терминал и подключенную к нему клавиатуру.
Даже если пользователь печатает со скоростью пулеметной очереди (600 знаков в минуту), ожидание в 100 мс между нажатиями клавиш по меркам процессора много и достаточно на исполнение 10 миллионов инструкций.

% Длительность записи на HDD
Устройства HDD для считывания и записи используют движущиеся части -- вращающийся диск и перемещающуюся считывающую головку.
На позиционирование головки тратится время около 10 мс.
За это время процессор может выполнить 1 миллион инструкций.

% Скорость передачи данных по сети
Скорость передачи данных через компьютерную сеть зависит от количества маршрутизаторов, через которые проходит путь пакетов, степени загрузки сетевого оборудования, качества инфраструктуры.
В локальных сетях, из-за их малых рамеров, издержки на передачу данных не велики и составляют около сотен микросекунд.
Но ситуация хуже для глобальной сети.
В них задержки составляют от 100 мс до нескольких секунд.

## Типы процессов

Существуют три типа процессов:
* системные;
* демоны;
* прикладные.

% Системные процессы
Системный процесс -- это часть ядра операционной системы.
Он обладает широкими привилегиями.
По сравнению с остальными процессами, он не запусается из исполняемого файла.

% Демоны и службы
Термин "демон" пришел из операционных систем типа UNIX.
Для Windows синонимом к нему являются службы.

Демон не принимает данные от клавиатуры и не выводит их на экран, то есть он не привязан к терминалу и пользователю.
Вместо этого демон связывается с другими программами и предоставляет им услуги.
Демоны обслуживают программы пользователей.

% Прикладные процессы
Прикладные процессы запускаются пользователем и привязаны к его терминалу.
Если пользователь выходит из системы, то его процессы завершаются.

## Многозадачность

В современном компьютере параллельно выполняются несколько программ.
Пользователь может одновременно слушать музыку, просматривать веб-страницы через браузер, держать запущенным почтовый клиент и мессенджер.
В фоновом режиме работают службы, предоставляющие услуги остальным программам.
Системные процессы операционной системы управляют ресурсами компьютера.

Один процессор может обслужить все программы за счет быстрого переключения между ними.
В итоге создается ощущение, что все процессы работают.
Такой способ организации выполнения команд называется **мультипрограммированием**.

Более полное использование ресурсов компьютера.

```
┌─────────────────────────────────────────┐
│             Physical memory             |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Process| │Process| │Process| ... │Process|
└───────┘ └───────┘ └───────┘     └───────┘
┌─────────────────────────────────────────┐
│               Physical CPU              |
└─────────────────────────────────────────┘
```

Из-за разного поведения программ и высокой производительности процессора появилась возможность мультипрограммирования за счет многозадачности.
Многозадачность поддерживается всеми современными операционными системами.
Так как UNIX изначально ориентировалась как многопользовательская система, то она поддерживает многозадачность с момента своего появления, с 1970 года.

## Модель процессов

```
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│memory | │memory | │memory |     │memory |
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Process| │Process| │Process| ... │Process|
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│  CPU  | │  CPU  | │  CPU  |     │  CPU  |
└───────┘ └───────┘ └───────┘     └───────┘
```

% Исполняемый код программы
Образ процесса

% Состояние процессора (регистры)
Исполнением программы занимается центральный процессор.
Процессор последовательно исполняет инструкции программы и формирует в регистрах и памяти результат.
То, какая инструкция должна быть выполнена следующей, показывает регистр процессора, называемый **счетчик адреса команд**.

% Данные процесса: стек
Вызов программной процедуры состоит из подготовки аргументов, сохранению текущего счетчика команд и загрузки нового значения счетчика, указывающего на местоположение процедуры.
Текущий счетчик команд и аргументы для передачи в процедуру сохраняются в стековой памяти.
Расположение вершины стека задается через регистр процессора **указатель на стек**.

% Данные процессора: данные

Для исполнения программы необходимы ресурсы: оперативная память для данных и стека, файлы, процессор с его регистрами.
Программа, данные и ресурсы составляют вместе процесс.

% Программные объекты ОС

% Несколько процессов одной программы
Программа может быть запущена несколько раз и каждому запуску будет соответствовать отдельный процесс.
Каждый процесс, хотя и обладает одними и теми же инструкциями, но будут иметь разные состояния (ресурсы и данные).

% Перемещение процесса

% Мутация процесса

## Планирование выполнения процессов

Какому процессу и на какое время отдать процессор решает **планировщик** (диспетчер задач) -- часть операционной системы.
От качества его работы зависит общая эффективность использования процессора и удовлетворенность пользователя.

То, как планировщик распределяет процессор между процессами называется **алгоритмом планирования**.

Самый простой способ планирования -- отдавать процессор активному процессу.

% Кооперативная многозадачность
Процесс может решить сам, когда ему отдавать процессор.
Преимущество. Не нужно защищать разделяемые структуры данных. Проще писать программы.

% Вытесняющая многозадачность
процесс снимается с процессора по истечению кванта времени или блокированию.

Блокированный процесс не может воспользоваться процессором, так как ожидает данные.

Выделяют три состояния, в которых может находиться процесс:
* выполняемый;
* готовый;
* заблокированный.

Простейшая диаграмма сотояния процесса показана ниже

```bash
┌──────────────┐   ┌───────────┐
│🏃 выполнение ├<─>┤ 🧍готовый │
└──────────┬───┘   └──┬────────┘
           ↓          ↑
        ┌──┴──────────┴────┐
        │ 🧘 блокированный │
        └──────────────────┘
```

Выполняемый процесс переходит в блокированное состояние после запроса отсутствюущих данных.
Для получения данных запрос перенаправляется устройству ввода.

## Иерархия процессов


## ⛏ Утилита ps

Утилита `ps` (**p**rocess **s**tatus) выводит отчет о состоянии процессов в системе.
По умолчанию утилита выводит краткую информацию о процессах пользователя, запущенных из терминала.
Одним из процессов будет сам `ps`.

```bash
skt@home:~$ ps
    PID TTY          TIME CMD
  34326 pts/0    00:00:00 bash
  84494 pts/0    00:00:00 ps
```

Первая строка содержит 4 заголовка, использующихся для описания процессов в последующих строках.
Вывод представляет таблицу из столбцов:
* `PID` -- идентификатор процесса.
* `TTY` -- связанный с процессом терминал.
* `TIME`-- процессорное время, которое досталось процессу.
* `CMD  -- команда, использованная для запуска.

Чтобы отобразить все процессы в системе используют опцию `-e` или ее синоним `-a`.
Таблица со всеми процессами вероятнее не хватит высоты экрана.
Удобнее перенаправить вывод `ps` для просмотра в `less` командой `ps -e | less` и уже там воспользоваться навигацией и поиском.

Чтобы узнать, сколько всего процессов в системе, включим нумерацию строк в `less` опцией `-N`.
Номер последней строки за вычетом первой строки покажет количество процессов.
Для подсчета символов, слов и строк существует утилита `wc`.
Она подсчитает только строки, если задать опцию `--line`: `ps -e | wc --line`.

Опция `-f` утилиты `ps` выведет дополнительные столбцы в отчете:
* `UID`   -- идентификатор пользователя, запустившего процесс.
* `PPID`  -- идентификатор родительского процесса.
* `C`     -- процент использования процессора.
* `STIME` -- время запуска процесса.

Столбец `CMD` содержит не только имя программы, как в первом случае, но и список ее аргументов.
Список аргументов для некоторых процессов настолько велик, что строки разбиваются на несколько строк, чтобы вместиться в ширину экрана.
Это разрушает структуру таблицы.
Опция `-S` утилиты `less` запрещает перенос строк:

```bash
ps -e -f | less -S
```

Значение `STIME` процесса `/sbin/init` покажет дату запуска операционной системы.

Иерархия процессов отображается опцией `-H`.
Дочерние процессы располагаются рядом сразу после родителя, а поле `CMD` отступает от родительского.
Опция `--forest` добавит в дерево ветки символами ASCII.
Утилита `pstree` нарисует дерево процессов более наглядно.

Опция `-l` утилиты `ps` выведет дополнительно следующие столбцы:
* `F`    -- флаги процесса.
* `S`    -- состояние процесса.
* `PRI` -- приоритет процесса.
* `NI`  -- уступчивость процесса (nice).
* `SZ`  -- размер процесса в физических страницах.

Поле `ADDR` и `WCHAN` интереса нам не представляют.

Состояние процесса:
* `D` -- ожидание ввода-вывода и не может быть прерван.
* `R` -- выполняется или в ожидании выполнения.
* `S` -- процесс в ожидании прерывания.
* `T` -- процесс остановлен (для отладки или сигналом Ctrl-Z).
* `Z` -- "зомби"-процесс.

## Жизненный цикл

### Создание процесса

Новый процесс может создать только другой процесс.

Самый первый процесс с ядром операционной системы появляется на компьютере благодаря загрузчику.
При включении компьютера управление передается BIOS -- небольшой программе, зашитой в микросхеме материнской платы.
BIOS из загрузочной части диска считывает программу-загрузчик, которая и загрузит операционную систему в оперативную память и передаст ей управление.

В системах UNIX ядро операционной системы запускает специальный процесс `init` из файла `/sbin/init` который будет являться родителем всех остальных процессов.

Запуск программ состоит из двух системных вызовов:
* `fork`, создание нового процесса;
* `execve`, запуск программы внутри процесса.

Создание процесса происходит через системный вызов операционной системы.
Системный вызов может выполнить только другой процесс.
Таким образом, новый процесс создается другим процессом.

Системный вызов `fork` раздваивает процесс на две части -- родительский и дочерний.

```c++
#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv)
{
  printf("Parent pid = %d\n", getpid());
  pid_t status = fork();
  if(status == -1)
  {
    printf("fork error\n");
    return 1;
  }
  if(status == 0)
  {
    printf("This is child with pid = %d\n", getpid());
  }
  else
  {
    printf("This is parent %d, fork child %d\n", getpid(), status);
  }
  return 0;
}
```

Процессу перед запуском передают два типа значений:
* аргументы программы;
* переменные окружения.

Они доступны программе из главной функции `main`:

```c++
extern char **environ;
int main(int argc, char* argv[])
{
  // ...
  return 0;
}
```

% Аргументы программы
% Переменные окружения
Набор строк типа "переменная=значение".
Все строки образуют окружение процесса.
* домашний каталог (`HOME`);
* 

### Завершение процесса

После завершения с процессом ассоциируется целое число, называемое **кодом завершения**.
Код завершения знаком нам как значение, возвращаемое главной функцией `main` в языках программирования Си и C++.

```c++
int main(int argc, char* argv[])
{
    // Некоторый код.
    // ...
    return 0; //< Код завершения
}
```

Его значение представлено типом int -- знаковым целым числом.
Но операционная система использует только его младшие 8 бит.
Поэтому из программы получится возвратить только целые числа в диапазоне [0, 255].
Это демонстрирует следующий код:

```c
#include <stdlib.h>
int main(int argc, char* argv[])
{
  return atoi(argv[1]);
}
```

Программа возвращает число, переданное первым аргументом.
В оболочке код возврата сохраняется в переменной `$?`.

```bash
skt@home:~$ gcc main.c -o program
skt@home:~$ ./program 256
skt@home:~$ echo $?
0
```

Общепринято, что успешно завершенная программа возвращает число 0.
А все остальные значения интерпретируются как ошибка.
Кодами 126 и 127 командная оболочка сообщает, что программа не найдена или не является исполняемой.

```bash
skt@home:~$ ./main.c
bash: ./main.c: Отказано в доступе
skt@home:~$ echo $?
126
skt@home:~$ lsxxx
lsxxx: команда не найдена
skt@home:~$ echo $?
127
```

Коды возврата выше 128 устанавливает операционная система по завершению процесса сигналом.

```bash
skt@home:~$ yes > /dev/null
^C
skt@home:~$ echo $?
130
```

Получается, что программа для обозначения ошибок может использовать коды только в диапазоне от 1 до 127.

Обычный способ завершить программу для программиста -- это выйти из функции `main` командой `return <number>`.
Кодом завершения процесса станет целое число `<number>`.
Но существует второй способ, удобный тем, что он позволяет завершить выполнение из любой процедуры.
Это функция `void exit(int)` стандартной библиотеки Си.

```c
#include <stdlib.h>

void func()
{
  exit(1);
}

int main(int argc, char* argv[])
{
  func();
  return 0;
}
```

```bash
skt@home:~$ gcc main.c -o program
skt@home:~$ ./program
skt@home:~$ echo $?
1
```

Оба способа выхода из программы (завершения процесса) через `return` и `exit` удобны тем, что уведомляют остальные части программы о скором завершении.
Это означает, что файловые буферы сбросятся на диск и выполнятся пользовательские функции, зарегистрированные через `int atexit(void(*func)(void))`.

Третий способ выхода из программы через системный вызов `void _exit(int)` завершает программу сразу, не предоставляя ему времени на подготовку.
Код ниже демонстрирует это.
Строка `hello` не сбросится на диск.
Но если убрать вызов функции `_exit(1)`, то файл был бы не пуст.

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char* argv[])
{
  FILE* file = fopen("x.txt", "w");
  fwrite("hello", 5, 1, file);
  _exit(1);
  return 0;
}
```

Выше мы рассмотрели способы завершения процесса по его собственному желанию.
Процесс могут также завершить операционная система и другой процесс.

Причина, по которой операционная система решает завершить процесс, связана с недопустимым поведением процесса.
Это обращение по недоступному адресу, попытка выполнить запрещенную инструкцию, деление на ноль.
Такие действия прерывают процессор, который сообщает об этом операционной системе.
Та в свою очередь уничтожает хулигана.

Прерывание процесса операционной системой выполняется отправкой сигнала.
Сигнал может отправить и другой процесс через системный вызов `int kill(pid_t, int)`.

Код завершения процесса предназначается для его родителя.
Родитель получает его посредством системного вызова `wait` (`waitpid`, `waitid`).
Функция блокирует родителя до тех пор, пока дочерний процесс не завершится.
Один из параметров функции проинициализируется кодом завершения.

О родительского процесса может быть много дочерних процессов.
Возникает вопрос: если родитель пропустит момент завершения дочерних процессов, то как он узнает о результатах их исполнения?
Дочерние процессы после завершения не удаляются из системы.
Они отмечаются особым статусом "зомби".
Зомби-процесс больше не рассматривается планировщиком.
Он просто ждет родителя, когда он опросит о его коде завершения.
После этого процесс исчезает из системы.


<!--
Модель процессов
Модель потоков
Создание процесса
Завершение процесса
Состояния процесса
Контекст процесса
Планирование
Сигналы
Управление заданиями
Утилита top
Асинхронное программирование
-->

## Сигналы

Операционная система управляет состоянием процесса через сигналы.
Сигнал предоставляет собой именованное событие, требующее реагирования на него процесса.
В ответ на сигнал выполнение процесса останавливается и вызывается специальная процедура, называемая **обработчиком сигнала**.
В обработчике прописаны действия на событие.
То, как надо реагировать на событие, устанавливает операционная система.
Процесс может переопределить обработчик, установив свою подпрограмму.
Но на некоторые типы сигнала установить обработчик не получится.

Для отправки сигнала операционная система предоставляет системный вызов `int kill(pid_t, int)`.
Первый аргумент указывает идентификатор процесса, которому посылается сигнал.
Тип сигнала указывается вторым параметром, которое указывает на информируемое сигналом событие.
Системный вызов для отправки сигналов позволяет управлять состоянием процесса и другим процессам.

```{tip}
Название функции заставляет волноваться.
Системный вызов опасности для пользователя не представляет, потому что первый аргумент указывает на процесс, а не пользователя (`uid_t`).
Иначе это выглядело бы как уничтожение процессом неугодного пользователя.
```

Часто сигналы применяют для завершения неугодного или провинившегося процесса, что и дало имя системному вызову.
Сигнал под номером 2 (`SIGINT`) посылается терминалом активному процессу в ответ на нажатие пользователем `Ctrl+Z`.
Сигнал просит процесс завершиться.
Если программа не переопределила стандартный обработчик, то процесс завершится системным вызовом `exit`.
Альтернативный обработчик может корректно освободить ресурсы, вывести информацию о завершении.
Но может проигнорировать сигнал и процесс будет выполняться дальше.

Немедленное завершение процессов происходит сигналом под номером 9(`SIGKILL`).
Для него невозможно заменить стандартный обработчик.

Для отправки сигнала пользователь может использовать одноименную утилиту `kill` в формате

```bash
kill 805
```

Сигналы к любому процессу может отправлять только суперпользователь.
Остальные пользователи ограничены процессами из своего круга.

## ⛏ Утилита top

Утилита `top` (**t**able **o**f **p**rocess) выводит обновляемый во времени отчет о состояниях процессов в системе.
Аналог диспетчера задач в Windows, но для UNIX в текстовом режиме.
Команды выхода из программы и вызова справки совпадают с `less` -- это `q` и `h`.
В отличие от `ps`, `top` -- интерактивная программа.

* `u<имя пользователя>` -- фильтрация процессов по пользователю.
* `u ` (`u` и пробел) -- вернуть обратно всех пользователей.
* `d<интервал в секундах>` -- интервал обновления отчета.
* `F` -- выбор столбца для сортировки.
* `f` -- выбор столбцов для показа.

Столбцы таблицы:
* `PID` -- идентификатор процесса.
* `USER` -- имя пользователя, запустившего процесс.
* `PR` -- приоритет процесса.
* `NI` -- уступчивость процесса.
* `S` -- состояние процесса.
* `%CPU` -- процент использованного процессорного времени.
* `TIME+` -- сотни процессорных секунд, использованных процессором.

`top` не поддерживает прокрутку экрана.
Содержимое за пределами экрана не просмотришь.
Это можно понять, если представить, что основная цель -- это посмотреть процессы, отсортированные по критериям.
Утилита `htop` обходит этот недостаток `top`.

## Управление заданиями


## Потоки

Потоки имеют общее адресное пространство, ресурсы ОС.

```
┌─────────────────────────────────────────┐
│            Virtual memory               |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Thread | │Thread | │Thread | ... │Thread |
└───────┘ └───────┘ └───────┘     └───────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│Virtual| │Virtual| │Virtual| ... │Virtual|
│  CPU  | │  CPU  | │  CPU  |     │  CPU  |
└───────┘ └───────┘ └───────┘     └───────┘
```


## Облегченные потоки

Облегченные потоки (fiber).
Реализованы в пространстве пользователя.

```
┌─────────────────────────────────────────┐
│              Virtual memory             |
└─────────────────────────────────────────┘
┌───────┐ ┌───────┐ ┌───────┐     ┌───────┐
│ Fiber | │ Fiber | │ Fiber | ... │ Fiber |
└───────┘ └───────┘ └───────┘     └───────┘
┌─────────────────────────────────────────┐
│               Virtual CPU               |
└─────────────────────────────────────────┘
```

% Блокирующие операции ввода-вывода
Процесс за данными обращается к операционной системе, используя системный вызов.
Операционная система перенаправляет запрос к устройству ввода, а процесс остается в ожидании данных.
Состояние ожидания данных называется **блокированием**, а приведшая к этому функция называется **блокирующей функцией**.
Чтобы процессор зазря не простаивал, заблокированный процесс снимается с исполнения с процессора.
Процессор передается другому процессу.

% Буферизация отправляемых данных.
Обратная операция, отправка данных на устройства вывода (запись в файл, отправка в сеть, вывод на экран), также медлительна.
Но в этом случае процесс не блокируется.
Данные сохраняются во внутренней памяти операционной системы.
Внутренняя память называется **буфером**, а накопление данных в буфере -- **буферизацией**.
Когда данные накапливаются достаточно (или буфер заполняется), происходит отправка данных на устройство вывода.
% Сброс буфера.

Человек по ходу своей жизни переходит в блокированное состояние.
Например, ожидание услуги, стоя в очереди.
Долгие очереди постепенно изживают себя, заменяясь предварительной записью, оптимизацией очередей подстраиванием обслуживания под возрастающие нагрузки, передачи документов и сообщение по телефону о подготовленных результатах.
% Синхронная неблокирующая функция -- занять очередь в разных местах и смотреть за их продвижением.
% Асинхронная неблокирующая функция -- занять очередь и попросить позвонить, если ваша очередь дойдет.

Аналогичный тренд наблюдается в программировании: блокирующие функции ввода-вывода заменяются **неблокирующими синхронными и асинхронными функциями**.
Альтернативой блокирующих функций является неблокирующие.
Неблокирующая функция проверяет готовность данных.
Если они готовы, то она возвращает результат, иначе вернет признак отсутствия.
Но программа не всегда может предугадать появление данных.
Каждый раз вызывать неблокирующую функцию неудобно.
В ответ на это используют неблокирующую асинхронную функцию.
Такая функция передает системе указатель на функцию, называемую также **функцией обратного вызова**.
Эта функция вызовестия системой, когда данные будут готовы.

## Асинхронный ввод-вывод


## Заключение

Знания о процессах и планировщике позволят создавать более эффективные программы.

## Использованные источники

1. [What Happens When A CPU Starts](https://lateblt.tripod.com/bit68.txt)
2. [Асинхронность в программировании](https://tproger.ru/articles/asynchronous-programming/)

# Процессы

## Введение

% Что такое процесс?
Процесс, наряду с файлом и адресным пространством, является ключевым понятием операционной системы.
Процесс возникает, когда программа запускается на исполнение.
Программа предлагает набор инструкций и данных для получения результата.

% Аналогия к программе и процессу -- приготовление блюда
Она похожа на кулинарную книгу с рецептами.
В ней прописаны список ингредиентов и последовательность действий для приготовления блюда.
Для приготовления блюда рецепта не достаточно.
Повару нужно исполнить действия, прописанные в рецепте.
Но предварительно он должен позаботиться об ингредиентах, подготовить кухонные инструменты, иметь стол и плиту.

% Про счетчик команд
Исполнением программы занимается центральный процессор.
Процессор последовательно исполняет инструкции программы и формирует в регистрах и памяти результат.
То, какая инструкция должна быть выполнена следующей, показывает регистр процессора, называемый **счетчик адреса команд**.

% Про стек процесса
Вызов программной процедуры состоит из подготовки аргументов, сохранению текущего счетчика команд и загрузки нового значения счетчика, указывающего на местоположение процедуры.
Текущий счетчик команд и аргументы для передачи в процедуру сохраняются в стековой памяти.
Расположение вершины стека задается через регистр процессора **указатель на стек**.

% Состояние процессора

% Оперативная память

Для исполнения программы необходимы ресурсы: оперативная память для данных и стека, файлы, процессор с его регистрами.
Программа, данные и ресурсы составляют вместе процесс.

% ???
Программа может быть запущена несколько раз и каждому запуску будет соответствовать отдельный процесс.
Каждый процесс, хотя и обладает одними и теми же инструкциями, но будут иметь разные состояния (ресурсы и данные).

Существуют три типа процессов:
* системные;
* демоны;
* прикладные.

% Системные процессы
Системный процесс -- это часть ядра операционной системы.
Он обладает широкими привилегиями.
По сравнению с остальными процессами, он не запусается из исполняемого файла.

% Демоны и службы
Термин "демон" пришел из операционных систем типа UNIX.
Для Windows синонимом к нему являются службы.

Демон не принимает данные от клавиатуры и не выводит их на экран, то есть он не привязан к терминалу и пользователю.
Вместо этого демон связывается с другими программами и предоставляет им услуги.
Демоны обслуживают программы пользователей.

% Прикладные процессы
Прикладные процессы запускаются пользователем и привязаны к его терминалу.
Если пользователь выходит из системы, то его процессы завершаются.

## Многозадачность

В современном компьютере параллельно выполняются несколько программ.
Пользователь может одновременно слушать музыку, просматривать веб-страницы через браузер, держать запущенным почтовый клиент и мессенджер.
В фоновом режиме работают службы, предоставляющие услуги остальным программам.
Системные процессы операционной системы управляют ресурсами компьютера.

Один процессор может обслужить все программы за счет быстрого переключения между ними.
В итоге создается ощущение, что все процессы работают.
Такой способ организации выполнения команд называется **мультипрограммированием**.

% Производительность современного процессора
Современный процессор на фоне остальных устройств обладает высокой производительностью.
Тактовая частота в 1 ГГц дает длительность одного такта в 1 нс или $10^{-9}$ секунды.
Инструкции процессора исполняются за 1-2 такта и до нескольких сотен тактов.
Длительность зависит от сложности инструкции, расположения операндов.
Если предположить в среднем 10 тактов на инструкцию, то при частоте 1 ГГц за одну секунду исполнится 100 миллионов инструкций.

% Прерывание процесса на операции ввода-вывода
Процесс не может постоянно использовать процессор.
Для продолжения вычислений ему нужны данные от пользователя и других процессов.
Эти данные запрашиваются у внешних устройств ввода -- клавиатуры, диска, сетевой карты.
Скорость получения данных от внешних устройств значительно мала, по сравнению со скоростью процессора.

% Длительность между нажатиями клавиш
Рассмотрим терминал и подключенную к нему клавиатуру.
Даже если пользователь печатает со скоростью пулеметной очереди (600 знаков в минуту), ожидание в 100 мс между нажатиями клавиш по меркам процессора много и достаточно на исполнение 10 миллионов инструкций.

% Длительность записи на HDD
Устройства HDD для считывания и записи используют движущиеся части -- вращающийся диск и перемещающуюся считывающую головку.
На позиционирование головки тратится время около 10 мс.
За это время процессор может выполнить 1 миллион инструкций.

% Скорость передачи данных по сети
Скорость передачи данных через компьютерную сеть зависит от количества маршрутизаторов, через которые проходит путь пакетов, степени загрузки сетевого оборудования, качества инфраструктуры.
В локальных сетях, из-за их малых рамеров, издержки на передачу данных не велики и составляют около сотен микросекунд.
Но ситуация хуже для глобальной сети.
В них задержки составляют от 100 мс до нескольких секунд.

% Блокирующие операции ввода-вывода
Процесс за данными обращается к операционной системе, используя системный вызов.
Операционная система перенаправляет запрос к устройству ввода, а процесс остается в ожидании данных.
Состояние ожидания данных называется **блокированием**, а приведшая к этому функция называется **блокирующей функцией**.
Чтобы процессор зазря не простаивал, заблокированный процесс снимается с исполнения с процессора.
Процессор передается другому процессу.

% Буферизация отправляемых данных.
Обратная операция, отправка данных на устройства вывода (запись в файл, отправка в сеть, вывод на экран), также медлительна.
Но в этом случае процесс не блокируется.
Данные сохраняются во внутренней памяти операционной системы.
Внутренняя память называется **буфером**, а накопление данных в буфере -- **буферизацией**.
Когда данные накапливаются достаточно (или буфер заполняется), происходит отправка данных на устройство вывода.
% Сброс буфера.

% Поведение интерактивных программ
Интерактивные программы большую часть своего времени находятся в ожидании данных от пользователя.
Нажатия клавиш, перемещения мыши и нажатия кнопок мыши создают события в программе.
Программа реагирует на события, обновляет свои внутренние данные и снова переходит в режим ожидания.

Программы архивирования данных типа `tar` и `gzip` не относятся к интерактивным.
Они обращаются к диску за порцией новых данных, сжимают их и записывают результат на диск.

Специальные программы для моделирования физических процессов, майнинг криптовалют, кодеки активно используют процессор и меньше обращаются к устройствам ввода и вывода.

Фоновые процессы, обслуживающие остальные процессы, неактивны пока к ним не обращаются.
При обращении к ним, они активируются для выполнения действия и затем снова отключаются.

По нагрузке на процессор и устройства ввода-вывода, процессы делятся на два типа:
* ограниченные скоростью вычислений;
* ограниченные скоростью работы устройств ввода-вывода.

Из-за разного поведения программ и высокой производительности процессора появилась возможность мультипрограммирования за счет многозадачности.
Многозадачность поддерживается всеми современными операционными системами.
Так как UNIX изначально ориентировалась как многопользовательская система, то она поддерживает многозадачность с момента своего появления, с 1970 года.

## Планирование выполнения процессов

Часть операционной системы, отвечающая за распределение процессора между процессами, называется **планировщиком**.
То, как планировщик распределяет процессор между процессами называется **алгоритмом планирования**.

% Кооперативная многозадачность
Процесс может решить сам, когда ему отдавать процессор.

% Вытесняющая многозадачность

Простейшая диаграмма сотояния процесса показана ниже

```bash
┌──────────────┐   ┌───────────┐
│🏃 выполнение ├<─>┤ 🧍готовый │
└──────────┬───┘   └──┬────────┘
           ↓          ↑
        ┌──┴──────────┴────┐
        │ 🧘 блокированный │
        └──────────────────┘
```

## Жизненный цикл

Самый главный процесс на компьютере -- это процесс с ядром операционной системы.
Он запускается загрузчиком, который в свою очередь запускает BIOS (UEFI).

### Создание процесса

Новый процесс может создать только другой процесс.

Самый первый процесс с ядром операционной системы появляется на компьютере благодаря загрузчику.
При включении компьютера управление передается BIOS -- небольшой программе, зашитой в микросхеме материнской платы.
BIOS из загрузочной части диска считывает программу-загрузчик, которая и загрузит операционную систему в оперативную память и передаст ей управление.

В системах UNIX ядро операционной системы запускает специальный процесс `init` из файла `/sbin/init` который будет являться родителем всех остальных процессов.

Запуск программ состоит из двух этапов:
* создание нового процесса;
* запуск программы в процессе.

Создание процесса происходит через системный вызов операционной системы.
Системный вызов может выполнить только другой процесс.
Таким образом, новый процесс создается другим процессом.

### Завершение процесса

После завершения с процессом ассоциируется целое число, называемое **кодом завершения**.
Код завершения знаком нам как значение, возвращаемое главной функцией `main` в языках программирования Си и C++.

```c
int main(int argc, char* argv[])
{
    // Некоторый код.
    // ...
    return 0; //< Код завершения
}
```

Его значение представлено типом int -- знаковым целым числом.
Но операционная система использует только его младшие 8 бит.
Поэтому из программы получится возвратить только целые числа в диапазоне [0, 255].
Это демонстрирует следующий код:

```c
#include <stdlib.h>
int main(int argc, char* argv[])
{
  return atoi(argv[1]);
}
```

Программа возвращает число, переданное первым аргументом.
В оболочке код возврата сохраняется в переменной `$?`.

```bash
skt@home:~$ gcc main.c -o program
skt@home:~$ ./program 256
skt@home:~$ echo $?
0
```

Общепринято, что успешно завершенная программа возвращает число 0.
А все остальные значения интерпретируются как ошибка.
Кодами 126 и 127 командная оболочка сообщает, что программа не найдена или не является исполняемой.

```bash
skt@home:~$ ./main.c
bash: ./main.c: Отказано в доступе
skt@home:~$ echo $?
126
skt@home:~$ lsxxx
lsxxx: команда не найдена
skt@home:~$ echo $?
127
```

Коды возврата выше 128 устанавливает операционная система по завершению процесса сигналом.

```bash
skt@home:~$ yes > /dev/null
^C
skt@home:~$ echo $?
130
```

Получается, что программа для обозначения ошибок может использовать коды только в диапазоне от 1 до 127.

Обычный способ завершить программу для программиста -- это выйти из функции `main` командой `return <number>`.
Кодом завершения процесса станет целое число `<number>`.
Но существует второй способ, удобный тем, что он позволяет завершить выполнение из любой процедуры.
Это функция `void exit(int)` стандартной библиотеки Си.

```c
#include <stdlib.h>

void func()
{
  exit(1);
}

int main(int argc, char* argv[])
{
  func();
  return 0;
}
```

```bash
skt@home:~$ gcc main.c -o program
skt@home:~$ ./program
skt@home:~$ echo $?
1
```

Оба способа выхода из программы (завершения процесса) через `return` и `exit` удобны тем, что уведомляют остальные части программы о скором завершении.
Это означает, что файловые буферы сбросятся на диск и выполнятся пользовательские функции, зарегистрированные через `int atexit(void(*func)(void))`.

Третий способ выхода из программы через системный вызов `void _exit(int)` завершает программу сразу, не предоставляя ему времени на подготовку.
Код ниже демонстрирует это.
Строка `hello` не сбросится на диск.
Но если убрать вызов функции `_exit(1)`, то файл был бы не пуст.

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char* argv[])
{
  FILE* file = fopen("x.txt", "w");
  fwrite("hello", 5, 1, file);
  _exit(1);
  return 0;
}
```

Выше мы рассмотрели способы завершения процесса по его собственному желанию.
Процесс могут также завершить операционная система и другой процесс.

Причина, по которой операционная система решает завершить процесс, связана с недопустимым поведением процесса.
Это обращение по недоступному адресу, попытка выполнить запрещенную инструкцию, деление на ноль.
Такие действия прерывают процессор, который сообщает об этом операционной системе.
Та в свою очередь уничтожает хулигана.

Прерывание процесса операционной системой выполняется отправкой сигнала.
Сигнал может отправить и другой процесс через системный вызов `int kill(pid_t, int)`.

Код завершения процесса предназначается для его родителя.
Родитель получает его посредством системного вызова `wait` (`waitpid`, `waitid`).
Функция блокирует родителя до тех пор, пока дочерний процесс не завершится.
Один из параметров функции проинициализируется кодом завершения.

О родительского процесса может быть много дочерних процессов.
Возникает вопрос: если родитель пропустит момент завершения дочерних процессов, то как он узнает о результатах их исполнения?
Дочерние процессы после завершения не удаляются из системы.
Они отмечаются особым статусом "зомби".
Зомби-процесс больше не рассматривается планировщиком.
Он просто ждет родителя, когда он опросит о его коде завершения.
После этого процесс исчезает из системы.

## Сигналы

## Передача информации процессам

% Аргументы командной строки
% Переменные окружения

## Потоки

## Управление заданиями

## Утилита ps

Утилита `ps` (**p**rocess **s**tatus) выводит отчет о состоянии процессов в системе.
По умолчанию утилита выводит краткую информацию о процессах пользователя, запущенных из терминала.
Одним из процессов будет сам `ps`.

```bash
skt@home:~$ ps
    PID TTY          TIME CMD
  34326 pts/0    00:00:00 bash
  84494 pts/0    00:00:00 ps
```

Первая строка содержит 4 заголовка, использующихся для описания процессов в последующих строках.
Вывод представляет таблицу из столбцов:
* `PID` -- идентификатор процесса.
* `TTY` -- связанный с процессом терминал.
* `TIME`-- процессорное время, которое досталось процессу.
* `CMD  -- команда, использованная для запуска.

Чтобы отобразить все процессы в системе используют опцию `-e` или ее синоним `-a`.
Таблица со всеми процессами вероятнее не хватит высоты экрана.
Удобнее перенаправить вывод `ps` для просмотра в `less` командой `ps -e | less` и уже там воспользоваться навигацией и поиском.

Чтобы узнать, сколько всего процессов в системе, включим нумерацию строк в `less` опцией `-N`.
Номер последней строки за вычетом первой строки покажет количество процессов.
Для подсчета символов, слов и строк существует утилита `wc`.
Она подсчитает только строки, если задать опцию `--line`: `ps -e | wc --line`.

Опция `-f` утилиты `ps` выведет дополнительные столбцы в отчете:
* `UID`   -- идентификатор пользователя, запустившего процесс.
* `PPID`  -- идентификатор родительского процесса.
* `C`     -- процент использования процессора.
* `STIME` -- время запуска процесса.

Столбец `CMD` содержит не только имя программы, как в первом случае, но и список ее аргументов.
Список аргументов для некоторых процессов настолько велик, что строки разбиваются на несколько строк, чтобы вместиться в ширину экрана.
Это разрушает структуру таблицы.
Опция `-S` утилиты `less` запрещает перенос строк:

```bash
ps -e -f | less -S
```

Значение `STIME` процесса `/sbin/init` покажет дату запуска операционной системы.

Иерархия процессов отображается опцией `-H`.
Дочерние процессы располагаются рядом сразу после родителя, а поле `CMD` отступает от родительского.
Опция `--forest` добавит в дерево ветки символами ASCII.
Утилита `pstree` нарисует дерево процессов более наглядно.

Опция `-l` утилиты `ps` выведет дополнительно следующие столбцы:
* `F`    -- флаги процесса.
* `S`    -- состояние процесса.
* `PRI` -- приоритет процесса.
* `NI`  -- уступчивость процесса (nice).
* `SZ`  -- размер процесса в физических страницах.

Поле `ADDR` и `WCHAN` интереса нам не представляют.

Состояние процесса:
* `D` -- ожидание ввода-вывода и не может быть прерван.
* `R` -- выполняется или в ожидании выполнения.
* `S` -- процесс в ожидании прерывания.
* `T` -- процесс остановлен (для отладки или сигналом Ctrl-Z).
* `Z` -- "зомби"-процесс.

## Утилита top

Утилита `top` (**t**able **o**f **p**rocess) выводит обновляемый во времени отчет о состояниях процессов в системе.
Аналог диспетчера задач в Windows, но для UNIX в текстовом режиме.
Команды выхода из программы и вызова справки совпадают с `less` -- это `q` и `h`.
В отличие от `ps`, `top` -- интерактивная программа.

* `u<имя пользователя>` -- фильтрация процессов по пользователю.
* `u ` (`u` и пробел) -- вернуть обратно всех пользователей.
* `d<интервал в секундах>` -- интервал обновления отчета.
* `F` -- выбор столбца для сортировки.
* `f` -- выбор столбцов для показа.

Столбцы таблицы:
* `PID` -- идентификатор процесса.
* `USER` -- имя пользователя, запустившего процесс.
* `PR` -- приоритет процесса.
* `NI` -- уступчивость процесса.
* `S` -- состояние процесса.
* `%CPU` -- процент использованного процессорного времени.
* `TIME+` -- сотни процессорных секунд, использованных процессором.

`top` не поддерживает прокрутку экрана.
Содержимое за пределами экрана не просмотришь.
Это можно понять, если представить, что основная цель -- это посмотреть процессы, отсортированные по критериям.
Утилита `htop` обходит этот недостаток `top`.

## Управление заданиями
